# Claude Code 教程系列 37：国际化与本地化实践

## 引言

在全球化的数字时代，软件应用需要服务于来自不同国家、文化和语言背景的用户。国际化（Internationalization，i18n）和本地化（Localization，l10n）是构建全球化应用的核心技术。Claude Code 作为智能编程助手，能够显著简化这一复杂过程，帮助开发者高效实现多语言、多区域的应用适配。本文将全面介绍如何利用 Claude Code 进行国际化与本地化实践。

## 目录
1. [国际化基础概念](#国际化基础概念)
2. [Claude Code辅助i18n开发](#claude-code辅助i18n开发)
3. [多语言文本管理系统](#多语言文本管理系统)
4. [动态内容本地化](#动态内容本地化)
5. [文化适配与UI调整](#文化适配与ui调整)
6. [自动化翻译工作流](#自动化翻译工作流)
7. [测试与质量保证](#测试与质量保证)
8. [实战项目案例](#实战项目案例)

## 国际化基础概念

### 1.1 i18n与l10n架构设计

让我们首先使用 Claude Code 构建一个完整的国际化框架：

```python
# i18n/core/internationalization.py
import json
import os
import re
import logging
from typing import Dict, List, Any, Optional, Union, Callable
from dataclasses import dataclass, field
from pathlib import Path
from datetime import datetime, date
from decimal import Decimal
import locale
from functools import lru_cache
import threading

@dataclass
class LocaleInfo:
    """区域信息"""
    code: str  # 如 'zh-CN', 'en-US'
    language: str  # 语言代码，如 'zh', 'en'
    country: str  # 国家代码，如 'CN', 'US'
    display_name: str  # 显示名称
    native_name: str  # 本地语言名称
    direction: str = "ltr"  # 文本方向：ltr（左到右）或 rtl（右到左）
    currency: str = "USD"  # 默认货币
    date_format: str = "%Y-%m-%d"  # 日期格式
    time_format: str = "%H:%M:%S"  # 时间格式
    decimal_separator: str = "."  # 小数分隔符
    thousand_separator: str = ","  # 千位分隔符

@dataclass
class TranslationEntry:
    """翻译条目"""
    key: str
    value: str
    context: Optional[str] = None
    description: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    last_modified: datetime = field(default_factory=datetime.now)
    translator: Optional[str] = None
    reviewed: bool = False

class InternationalizationCore:
    """国际化核心系统"""
    
    def __init__(self, default_locale: str = "en-US", translations_dir: str = "translations"):
        self.default_locale = default_locale
        self.current_locale = default_locale
        self.translations_dir = Path(translations_dir)
        self.translations_dir.mkdir(exist_ok=True)
        
        # 缓存和状态管理
        self.translations: Dict[str, Dict[str, TranslationEntry]] = {}
        self.locales: Dict[str, LocaleInfo] = {}
        self.fallback_chain: Dict[str, List[str]] = {}
        self.pluralization_rules: Dict[str, Callable] = {}
        self.formatters: Dict[str, Dict[str, Callable]] = {}
        
        # 线程安全
        self._lock = threading.RLock()
        
        # 日志系统
        self.logger = logging.getLogger(__name__)
        
        # 初始化核心区域
        self._initialize_core_locales()
        self._initialize_pluralization_rules()
        self._initialize_formatters()
        
        # 加载翻译
        self.load_all_translations()
    
    def _initialize_core_locales(self):
        """初始化核心区域设置"""
        core_locales = {
            "en-US": LocaleInfo(
                code="en-US",
                language="en",
                country="US",
                display_name="English (United States)",
                native_name="English (United States)",
                direction="ltr",
                currency="USD",
                date_format="%m/%d/%Y",
                time_format="%I:%M %p"
            ),
            "zh-CN": LocaleInfo(
                code="zh-CN",
                language="zh",
                country="CN",
                display_name="Chinese (Simplified)",
                native_name="中文（简体）",
                direction="ltr",
                currency="CNY",
                date_format="%Y年%m月%d日",
                time_format="%H:%M",
                decimal_separator=".",
                thousand_separator=","
            ),
            "ja-JP": LocaleInfo(
                code="ja-JP",
                language="ja",
                country="JP",
                display_name="Japanese",
                native_name="日本語",
                direction="ltr",
                currency="JPY",
                date_format="%Y年%m月%d日",
                time_format="%H:%M"
            ),
            "ar-SA": LocaleInfo(
                code="ar-SA",
                language="ar",
                country="SA",
                display_name="Arabic (Saudi Arabia)",
                native_name="العربية (السعودية)",
                direction="rtl",
                currency="SAR",
                date_format="%d/%m/%Y",
                time_format="%H:%M"
            ),
            "de-DE": LocaleInfo(
                code="de-DE",
                language="de",
                country="DE",
                display_name="German (Germany)",
                native_name="Deutsch (Deutschland)",
                direction="ltr",
                currency="EUR",
                date_format="%d.%m.%Y",
                time_format="%H:%M"
            ),
            "fr-FR": LocaleInfo(
                code="fr-FR",
                language="fr",
                country="FR",
                display_name="French (France)",
                native_name="Français (France)",
                direction="ltr",
                currency="EUR",
                date_format="%d/%m/%Y",
                time_format="%H:%M"
            ),
            "es-ES": LocaleInfo(
                code="es-ES",
                language="es",
                country="ES",
                display_name="Spanish (Spain)",
                native_name="Español (España)",
                direction="ltr",
                currency="EUR",
                date_format="%d/%m/%Y",
                time_format="%H:%M"
            )
        }
        
        self.locales.update(core_locales)
        
        # 设置回退链
        self.fallback_chain = {
            "zh-CN": ["zh-TW", "en-US"],
            "zh-TW": ["zh-CN", "en-US"],
            "ja-JP": ["en-US"],
            "ko-KR": ["en-US"],
            "ar-SA": ["ar-EG", "en-US"],
            "de-DE": ["en-US"],
            "fr-FR": ["en-US"],
            "es-ES": ["es-MX", "en-US"]
        }
    
    def _initialize_pluralization_rules(self):
        """初始化复数规则"""
        def english_plural_rule(n: int) -> str:
            return "other" if n != 1 else "one"
        
        def chinese_plural_rule(n: int) -> str:
            return "other"  # 中文没有复数形式
        
        def arabic_plural_rule(n: int) -> str:
            if n == 0:
                return "zero"
            elif n == 1:
                return "one"
            elif n == 2:
                return "two"
            elif 3 <= n <= 10:
                return "few"
            elif 11 <= n <= 99:
                return "many"
            else:
                return "other"
        
        def german_plural_rule(n: int) -> str:
            return "other" if n != 1 else "one"
        
        self.pluralization_rules = {
            "en": english_plural_rule,
            "zh": chinese_plural_rule,
            "ja": chinese_plural_rule,
            "ko": chinese_plural_rule,
            "ar": arabic_plural_rule,
            "de": german_plural_rule,
            "fr": german_plural_rule,
            "es": german_plural_rule
        }
    
    def _initialize_formatters(self):
        """初始化格式化器"""
        def format_currency(amount: Union[int, float, Decimal], locale_code: str) -> str:
            locale_info = self.locales.get(locale_code)
            if not locale_info:
                return f"${amount:.2f}"
            
            # 简化的货币格式化
            currency_symbols = {
                "USD": "$", "CNY": "¥", "JPY": "¥", "EUR": "€", 
                "GBP": "£", "SAR": "ر.س", "KRW": "₩"
            }
            
            symbol = currency_symbols.get(locale_info.currency, locale_info.currency)
            
            # 格式化数字
            if locale_info.currency == "JPY":
                formatted = f"{int(amount):,}"
            else:
                formatted = f"{float(amount):,.2f}"
            
            # 应用本地化分隔符
            if locale_info.thousand_separator != ",":
                formatted = formatted.replace(",", locale_info.thousand_separator)
            if locale_info.decimal_separator != ".":
                formatted = formatted.replace(".", locale_info.decimal_separator)
            
            return f"{symbol}{formatted}"
        
        def format_date(date_obj: Union[date, datetime], locale_code: str) -> str:
            locale_info = self.locales.get(locale_code)
            if not locale_info:
                return date_obj.strftime("%Y-%m-%d")
            
            return date_obj.strftime(locale_info.date_format)
        
        def format_time(time_obj: Union[datetime], locale_code: str) -> str:
            locale_info = self.locales.get(locale_code)
            if not locale_info:
                return time_obj.strftime("%H:%M:%S")
            
            return time_obj.strftime(locale_info.time_format)
        
        def format_number(num: Union[int, float], locale_code: str) -> str:
            locale_info = self.locales.get(locale_code)
            if not locale_info:
                return f"{num:,}"
            
            formatted = f"{num:,}"
            if locale_info.thousand_separator != ",":
                formatted = formatted.replace(",", locale_info.thousand_separator)
            
            return formatted
        
        # 为每个区域设置格式化器
        for locale_code in self.locales:
            self.formatters[locale_code] = {
                "currency": lambda amount, loc=locale_code: format_currency(amount, loc),
                "date": lambda date_obj, loc=locale_code: format_date(date_obj, loc),
                "time": lambda time_obj, loc=locale_code: format_time(time_obj, loc),
                "number": lambda num, loc=locale_code: format_number(num, loc)
            }
    
    def register_locale(self, locale_info: LocaleInfo):
        """注册新的区域"""
        with self._lock:
            self.locales[locale_info.code] = locale_info
            self.logger.info(f"已注册区域: {locale_info.code}")
    
    def set_locale(self, locale_code: str) -> bool:
        """设置当前区域"""
        if locale_code not in self.locales:
            self.logger.error(f"未找到区域: {locale_code}")
            return False
        
        with self._lock:
            self.current_locale = locale_code
            self.logger.info(f"当前区域已设置为: {locale_code}")
            return True
    
    def get_current_locale(self) -> LocaleInfo:
        """获取当前区域信息"""
        return self.locales.get(self.current_locale, self.locales[self.default_locale])
    
    def load_translations(self, locale_code: str) -> bool:
        """加载指定区域的翻译"""
        translation_file = self.translations_dir / f"{locale_code}.json"
        
        if not translation_file.exists():
            self.logger.warning(f"翻译文件不存在: {translation_file}")
            return False
        
        try:
            with open(translation_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            translations = {}
            for key, value in data.items():
                if isinstance(value, str):
                    translations[key] = TranslationEntry(key=key, value=value)
                elif isinstance(value, dict):
                    translations[key] = TranslationEntry(
                        key=key,
                        value=value.get('value', ''),
                        context=value.get('context'),
                        description=value.get('description'),
                        tags=value.get('tags', []),
                        translator=value.get('translator'),
                        reviewed=value.get('reviewed', False)
                    )
            
            with self._lock:
                self.translations[locale_code] = translations
            
            self.logger.info(f"已加载 {locale_code} 的 {len(translations)} 条翻译")
            return True
        
        except Exception as e:
            self.logger.error(f"加载翻译失败 {translation_file}: {e}")
            return False
    
    def load_all_translations(self):
        """加载所有可用的翻译"""
        for locale_code in self.locales:
            self.load_translations(locale_code)
    
    def save_translations(self, locale_code: str) -> bool:
        """保存翻译到文件"""
        if locale_code not in self.translations:
            self.logger.error(f"没有找到区域 {locale_code} 的翻译")
            return False
        
        translation_file = self.translations_dir / f"{locale_code}.json"
        
        try:
            data = {}
            for key, entry in self.translations[locale_code].items():
                data[key] = {
                    "value": entry.value,
                    "context": entry.context,
                    "description": entry.description,
                    "tags": entry.tags,
                    "last_modified": entry.last_modified.isoformat(),
                    "translator": entry.translator,
                    "reviewed": entry.reviewed
                }
            
            with open(translation_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            self.logger.info(f"已保存 {locale_code} 的翻译到 {translation_file}")
            return True
        
        except Exception as e:
            self.logger.error(f"保存翻译失败 {translation_file}: {e}")
            return False
    
    @lru_cache(maxsize=1000)
    def translate(self, key: str, locale_code: Optional[str] = None, 
                  default: Optional[str] = None, **kwargs) -> str:
        """翻译文本"""
        target_locale = locale_code or self.current_locale
        
        # 尝试获取翻译
        translation = self._get_translation(key, target_locale)
        
        if translation is None:
            # 使用回退链
            for fallback_locale in self.fallback_chain.get(target_locale, []):
                translation = self._get_translation(key, fallback_locale)
                if translation:
                    break
        
        if translation is None:
            # 使用默认值或返回键名
            translation = default or key
            self.logger.warning(f"未找到翻译: {key} (区域: {target_locale})")
        
        # 处理参数替换
        if kwargs:
            try:
                translation = translation.format(**kwargs)
            except (KeyError, ValueError) as e:
                self.logger.error(f"翻译参数替换失败 {key}: {e}")
        
        return translation
    
    def _get_translation(self, key: str, locale_code: str) -> Optional[str]:
        """获取指定区域的翻译"""
        translations = self.translations.get(locale_code, {})
        entry = translations.get(key)
        return entry.value if entry else None
    
    def translate_plural(self, key: str, count: int, locale_code: Optional[str] = None, 
                        default: Optional[str] = None, **kwargs) -> str:
        """复数翻译"""
        target_locale = locale_code or self.current_locale
        language = self.locales.get(target_locale, self.locales[self.default_locale]).language
        
        # 获取复数规则
        plural_rule = self.pluralization_rules.get(language, self.pluralization_rules["en"])
        plural_form = plural_rule(count)
        
        # 构建复数键
        plural_key = f"{key}.{plural_form}"
        
        # 尝试获取复数翻译
        translation = self.translate(plural_key, target_locale, default)
        
        # 如果没有找到复数形式，回退到基础键
        if translation == plural_key and default is None:
            translation = self.translate(key, target_locale, default)
        
        # 添加计数参数
        kwargs['count'] = count
        
        # 处理参数替换
        if kwargs:
            try:
                translation = translation.format(**kwargs)
            except (KeyError, ValueError) as e:
                self.logger.error(f"复数翻译参数替换失败 {plural_key}: {e}")
        
        return translation
    
    def format_currency(self, amount: Union[int, float, Decimal], 
                       locale_code: Optional[str] = None) -> str:
        """格式化货币"""
        target_locale = locale_code or self.current_locale
        formatter = self.formatters.get(target_locale, {}).get("currency")
        
        if formatter:
            return formatter(amount)
        else:
            return f"${amount:.2f}"
    
    def format_date(self, date_obj: Union[date, datetime], 
                   locale_code: Optional[str] = None) -> str:
        """格式化日期"""
        target_locale = locale_code or self.current_locale
        formatter = self.formatters.get(target_locale, {}).get("date")
        
        if formatter:
            return formatter(date_obj)
        else:
            return date_obj.strftime("%Y-%m-%d")
    
    def format_time(self, time_obj: datetime, 
                   locale_code: Optional[str] = None) -> str:
        """格式化时间"""
        target_locale = locale_code or self.current_locale
        formatter = self.formatters.get(target_locale, {}).get("time")
        
        if formatter:
            return formatter(time_obj)
        else:
            return time_obj.strftime("%H:%M:%S")
    
    def format_number(self, num: Union[int, float], 
                     locale_code: Optional[str] = None) -> str:
        """格式化数字"""
        target_locale = locale_code or self.current_locale
        formatter = self.formatters.get(target_locale, {}).get("number")
        
        if formatter:
            return formatter(num)
        else:
            return f"{num:,}"
    
    def add_translation(self, key: str, value: str, locale_code: str,
                       context: Optional[str] = None, description: Optional[str] = None,
                       tags: Optional[List[str]] = None) -> bool:
        """添加翻译条目"""
        try:
            with self._lock:
                if locale_code not in self.translations:
                    self.translations[locale_code] = {}
                
                entry = TranslationEntry(
                    key=key,
                    value=value,
                    context=context,
                    description=description,
                    tags=tags or []
                )
                
                self.translations[locale_code][key] = entry
            
            # 清除缓存
            self.translate.cache_clear()
            
            self.logger.info(f"已添加翻译: {key} -> {value} (区域: {locale_code})")
            return True
        
        except Exception as e:
            self.logger.error(f"添加翻译失败: {e}")
            return False
    
    def get_available_locales(self) -> List[LocaleInfo]:
        """获取所有可用区域"""
        return list(self.locales.values())
    
    def get_translation_progress(self, locale_code: str) -> Dict[str, Any]:
        """获取翻译进度"""
        if locale_code not in self.translations:
            return {"error": f"区域 {locale_code} 不存在"}
        
        base_translations = self.translations.get(self.default_locale, {})
        target_translations = self.translations.get(locale_code, {})
        
        total_keys = len(base_translations)
        translated_keys = len([k for k in base_translations.keys() if k in target_translations])
        reviewed_keys = len([k for k, v in target_translations.items() if v.reviewed])
        
        progress = {
            "locale": locale_code,
            "total_keys": total_keys,
            "translated_keys": translated_keys,
            "reviewed_keys": reviewed_keys,
            "translation_progress": (translated_keys / max(total_keys, 1)) * 100,
            "review_progress": (reviewed_keys / max(translated_keys, 1)) * 100 if translated_keys > 0 else 0,
            "missing_keys": [k for k in base_translations.keys() if k not in target_translations][:10]  # 显示前10个
        }
        
        return progress

# 全局实例
i18n = InternationalizationCore()

# 便捷函数
def _(key: str, **kwargs) -> str:
    """翻译函数的简化版本"""
    return i18n.translate(key, **kwargs)

def _n(key: str, count: int, **kwargs) -> str:
    """复数翻译函数的简化版本"""
    return i18n.translate_plural(key, count, **kwargs)

def set_locale(locale_code: str) -> bool:
    """设置当前区域"""
    return i18n.set_locale(locale_code)

def get_locale() -> str:
    """获取当前区域代码"""
    return i18n.current_locale

# 使用示例
def demo_internationalization():
    """演示国际化功能"""
    # 添加一些翻译
    i18n.add_translation("hello", "Hello", "en-US")
    i18n.add_translation("hello", "你好", "zh-CN")
    i18n.add_translation("hello", "こんにちは", "ja-JP")
    i18n.add_translation("hello", "مرحبا", "ar-SA")
    
    # 复数翻译
    i18n.add_translation("item.one", "You have {count} item", "en-US")
    i18n.add_translation("item.other", "You have {count} items", "en-US")
    i18n.add_translation("item.other", "你有{count}个物品", "zh-CN")
    
    # 测试不同区域
    locales_to_test = ["en-US", "zh-CN", "ja-JP", "ar-SA"]
    
    for locale in locales_to_test:
        set_locale(locale)
        print(f"\n区域: {locale}")
        print(f"问候: {_('hello')}")
        print(f"单数: {_n('item', 1)}")
        print(f"复数: {_n('item', 5)}")
        
        # 格式化测试
        from datetime import datetime
        now = datetime.now()
        print(f"日期: {i18n.format_date(now)}")
        print(f"时间: {i18n.format_time(now)}")
        print(f"货币: {i18n.format_currency(1234.56)}")
        print(f"数字: {i18n.format_number(1234567)}")
        
        locale_info = i18n.get_current_locale()
        print(f"文本方向: {locale_info.direction}")

# 运行演示
if __name__ == "__main__":
    demo_internationalization()
```

## Claude Code辅助i18n开发

### 2.1 智能翻译键提取

使用 Claude Code 自动从源代码中提取需要翻译的文本：

```python
# i18n/tools/text_extractor.py
import ast
import re
import json
import os
from typing import Dict, List, Set, Tuple, Optional
from pathlib import Path
from dataclasses import dataclass
import logging

@dataclass
class ExtractedText:
    """提取的文本信息"""
    text: str
    key: str
    file_path: str
    line_number: int
    context: str
    function_name: Optional[str] = None
    class_name: Optional[str] = None
    description: Optional[str] = None

class TextExtractor:
    """文本提取器"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.extracted_texts: List[ExtractedText] = []
        self.existing_keys: Set[str] = set()
        self.logger = logging.getLogger(__name__)
        
        # 配置模式
        self.patterns = {
            'string_literals': r'["\']([^"\'\\]|\\.)*["\']',
            'user_facing_strings': [
                r'print\s*\(\s*["\']([^"\']*)["\']',
                r'message\s*=\s*["\']([^"\']*)["\']',
                r'title\s*=\s*["\']([^"\']*)["\']',
                r'label\s*=\s*["\']([^"\']*)["\']',
                r'placeholder\s*=\s*["\']([^"\']*)["\']',
                r'error\s*=\s*["\']([^"\']*)["\']',
                r'warning\s*=\s*["\']([^"\']*)["\']',
                r'success\s*=\s*["\']([^"\']*)["\']'
            ]
        }
        
        # 忽略的文件和目录
        self.ignore_patterns = {
            'directories': {'.git', '__pycache__', 'node_modules', '.venv', 'env'},
            'files': {'*.pyc', '*.log', '*.tmp'},
            'extensions': {'.log', '.tmp', '.pyc', '.pyo'}
        }
        
        # 忽略的字符串模式
        self.ignore_strings = {
            r'^\s*$',  # 空字符串
            r'^[a-zA-Z_][a-zA-Z0-9_]*$',  # 变量名
            r'^\d+$',  # 纯数字
            r'^[^a-zA-Z\u4e00-\u9fff]*$',  # 不包含字母和中文的字符串
            r'^(debug|info|warning|error|critical)$',  # 日志级别
            r'^(GET|POST|PUT|DELETE|HEAD|OPTIONS|PATCH)$',  # HTTP方法
            r'^application/json$',  # MIME类型
        }
    
    def extract_from_python_file(self, file_path: Path) -> List[ExtractedText]:
        """从Python文件中提取文本"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            tree = ast.parse(content)
            extractor = PythonTextVisitor(str(file_path))
            extractor.visit(tree)
            
            return extractor.extracted_texts
        
        except Exception as e:
            self.logger.error(f"解析Python文件失败 {file_path}: {e}")
            return []
    
    def extract_from_javascript_file(self, file_path: Path) -> List[ExtractedText]:
        """从JavaScript文件中提取文本（使用正则表达式）"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            extracted = []
            lines = content.splitlines()
            
            # 匹配常见的用户界面字符串
            patterns = [
                r'alert\s*\(\s*["\']([^"\']*)["\']',
                r'confirm\s*\(\s*["\']([^"\']*)["\']',
                r'prompt\s*\(\s*["\']([^"\']*)["\']',
                r'innerHTML\s*=\s*["\']([^"\']*)["\']',
                r'textContent\s*=\s*["\']([^"\']*)["\']',
                r'placeholder\s*:\s*["\']([^"\']*)["\']',
                r'title\s*:\s*["\']([^"\']*)["\']',
                r'label\s*:\s*["\']([^"\']*)["\']'
            ]
            
            for line_num, line in enumerate(lines, 1):
                for pattern in patterns:
                    matches = re.finditer(pattern, line)
                    for match in matches:
                        text = match.group(1)
                        if self._should_extract_text(text):
                            key = self._generate_key(text)
                            extracted.append(ExtractedText(
                                text=text,
                                key=key,
                                file_path=str(file_path),
                                line_number=line_num,
                                context=line.strip(),
                                description=f"JavaScript string from {file_path.name}"
                            ))
            
            return extracted
        
        except Exception as e:
            self.logger.error(f"解析JavaScript文件失败 {file_path}: {e}")
            return []
    
    def extract_from_html_file(self, file_path: Path) -> List[ExtractedText]:
        """从HTML文件中提取文本"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            extracted = []
            lines = content.splitlines()
            
            # HTML标签内容模式
            patterns = [
                r'<title[^>]*>([^<]+)</title>',
                r'<h[1-6][^>]*>([^<]+)</h[1-6]>',
                r'<p[^>]*>([^<]+)</p>',
                r'<button[^>]*>([^<]+)</button>',
                r'<a[^>]*>([^<]+)</a>',
                r'<span[^>]*>([^<]+)</span>',
                r'<div[^>]*>([^<]+)</div>',
                r'placeholder\s*=\s*["\']([^"\']*)["\']',
                r'alt\s*=\s*["\']([^"\']*)["\']',
                r'title\s*=\s*["\']([^"\']*)["\']'
            ]
            
            for line_num, line in enumerate(lines, 1):
                for pattern in patterns:
                    matches = re.finditer(pattern, line, re.IGNORECASE)
                    for match in matches:
                        text = match.group(1).strip()
                        if self._should_extract_text(text):
                            key = self._generate_key(text)
                            extracted.append(ExtractedText(
                                text=text,
                                key=key,
                                file_path=str(file_path),
                                line_number=line_num,
                                context=line.strip(),
                                description=f"HTML content from {file_path.name}"
                            ))
            
            return extracted
        
        except Exception as e:
            self.logger.error(f"解析HTML文件失败 {file_path}: {e}")
            return []
    
    def _should_extract_text(self, text: str) -> bool:
        """判断文本是否应该被提取"""
        if not text or len(text.strip()) < 2:
            return False
        
        # 检查忽略模式
        for pattern in self.ignore_strings:
            if re.match(pattern, text.strip(), re.IGNORECASE):
                return False
        
        # 检查是否包含有意义的内容
        # 至少包含一个字母、中文字符或其他有意义的字符
        meaningful_chars = re.search(r'[a-zA-Z\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\u0600-\u06ff]', text)
        if not meaningful_chars:
            return False
        
        return True
    
    def _generate_key(self, text: str) -> str:
        """生成翻译键"""
        # 简化文本作为键
        key = re.sub(r'[^\w\s]', '', text.lower())  # 移除标点符号
        key = re.sub(r'\s+', '_', key.strip())  # 将空格替换为下划线
        key = key[:50]  # 限制长度
        
        # 确保键的唯一性
        original_key = key
        counter = 1
        while key in self.existing_keys:
            key = f"{original_key}_{counter}"
            counter += 1
        
        self.existing_keys.add(key)
        return key
    
    def _should_ignore_file(self, file_path: Path) -> bool:
        """判断文件是否应该被忽略"""
        # 检查目录
        for part in file_path.parts:
            if part in self.ignore_patterns['directories']:
                return True
        
        # 检查扩展名
        if file_path.suffix in self.ignore_patterns['extensions']:
            return True
        
        return False
    
    def extract_from_project(self) -> List[ExtractedText]:
        """从整个项目中提取文本"""
        self.extracted_texts.clear()
        self.existing_keys.clear()
        
        # 支持的文件类型及其处理函数
        extractors = {
            '.py': self.extract_from_python_file,
            '.js': self.extract_from_javascript_file,
            '.jsx': self.extract_from_javascript_file,
            '.ts': self.extract_from_javascript_file,
            '.tsx': self.extract_from_javascript_file,
            '.html': self.extract_from_html_file,
            '.htm': self.extract_from_html_file
        }
        
        # 遍历项目文件
        for file_path in self.project_root.rglob('*'):
            if not file_path.is_file() or self._should_ignore_file(file_path):
                continue
            
            extractor = extractors.get(file_path.suffix)
            if extractor:
                try:
                    texts = extractor(file_path)
                    self.extracted_texts.extend(texts)
                except Exception as e:
                    self.logger.error(f"提取文件失败 {file_path}: {e}")
        
        self.logger.info(f"从项目中提取了 {len(self.extracted_texts)} 个文本")
        return self.extracted_texts
    
    def generate_translation_template(self, output_file: Optional[str] = None) -> Dict[str, Any]:
        """生成翻译模板"""
        template = {}
        
        for text_info in self.extracted_texts:
            template[text_info.key] = {
                "value": text_info.text,
                "context": text_info.context,
                "description": text_info.description,
                "file": text_info.file_path,
                "line": text_info.line_number
            }
        
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(template, f, ensure_ascii=False, indent=2)
            
            self.logger.info(f"翻译模板已保存到: {output_file}")
        
        return template
    
    def generate_i18n_report(self) -> Dict[str, Any]:
        """生成国际化报告"""
        # 按文件统计
        files_stats = {}
        for text_info in self.extracted_texts:
            if text_info.file_path not in files_stats:
                files_stats[text_info.file_path] = 0
            files_stats[text_info.file_path] += 1
        
        # 按文件类型统计
        extension_stats = {}
        for text_info in self.extracted_texts:
            ext = Path(text_info.file_path).suffix
            if ext not in extension_stats:
                extension_stats[ext] = 0
            extension_stats[ext] += 1
        
        report = {
            "summary": {
                "total_texts": len(self.extracted_texts),
                "unique_keys": len(self.existing_keys),
                "files_processed": len(files_stats)
            },
            "by_file": dict(sorted(files_stats.items(), key=lambda x: x[1], reverse=True)[:10]),
            "by_extension": extension_stats,
            "sample_texts": [
                {
                    "text": t.text,
                    "key": t.key,
                    "file": t.file_path,
                    "line": t.line_number
                }
                for t in self.extracted_texts[:10]
            ]
        }
        
        return report

class PythonTextVisitor(ast.NodeVisitor):
    """Python AST访问器，用于提取文本"""
    
    def __init__(self, file_path: str):
        self.file_path = file_path
        self.extracted_texts: List[ExtractedText] = []
        self.current_class = None
        self.current_function = None
        self.existing_keys: Set[str] = set()
    
    def visit_ClassDef(self, node):
        old_class = self.current_class
        self.current_class = node.name
        self.generic_visit(node)
        self.current_class = old_class
    
    def visit_FunctionDef(self, node):
        old_function = self.current_function
        self.current_function = node.name
        self.generic_visit(node)
        self.current_function = old_function
    
    def visit_Str(self, node):  # Python < 3.8
        self._process_string(node.s, node.lineno, node.col_offset)
    
    def visit_Constant(self, node):  # Python >= 3.8
        if isinstance(node.value, str):
            self._process_string(node.value, node.lineno, node.col_offset)
    
    def _process_string(self, text: str, line_num: int, col_offset: int):
        """处理字符串节点"""
        if self._should_extract_text(text):
            key = self._generate_key(text)
            
            # 尝试获取更多上下文信息
            context = f"Line {line_num}, Column {col_offset}"
            if self.current_function:
                context += f", in function {self.current_function}"
            if self.current_class:
                context += f", in class {self.current_class}"
            
            self.extracted_texts.append(ExtractedText(
                text=text,
                key=key,
                file_path=self.file_path,
                line_number=line_num,
                context=context,
                function_name=self.current_function,
                class_name=self.current_class,
                description=f"String literal from Python code"
            ))
    
    def _should_extract_text(self, text: str) -> bool:
        """判断文本是否应该被提取"""
        if not text or len(text.strip()) < 2:
            return False
        
        # 忽略模式
        ignore_patterns = [
            r'^\s*$',  # 空字符串
            r'^[a-zA-Z_][a-zA-Z0-9_]*$',  # 变量名
            r'^\d+$',  # 纯数字
            r'^[^a-zA-Z\u4e00-\u9fff]*$',  # 不包含字母和中文
            r'^(debug|info|warning|error|critical)$',  # 日志级别
        ]
        
        for pattern in ignore_patterns:
            if re.match(pattern, text.strip(), re.IGNORECASE):
                return False
        
        return True
    
    def _generate_key(self, text: str) -> str:
        """生成翻译键"""
        key = re.sub(r'[^\w\s]', '', text.lower())
        key = re.sub(r'\s+', '_', key.strip())
        key = key[:50]
        
        original_key = key
        counter = 1
        while key in self.existing_keys:
            key = f"{original_key}_{counter}"
            counter += 1
        
        self.existing_keys.add(key)
        return key

# 使用示例
def demo_text_extraction():
    """演示文本提取功能"""
    extractor = TextExtractor('.')
    
    # 提取所有文本
    extracted_texts = extractor.extract_from_project()
    
    # 生成报告
    report = extractor.generate_i18n_report()
    print("国际化报告:")
    print(json.dumps(report, indent=2, ensure_ascii=False))
    
    # 生成翻译模板
    template = extractor.generate_translation_template('translation_template.json')
    print(f"\n生成了 {len(template)} 个翻译键")
    
    # 显示一些示例
    print("\n示例提取的文本:")
    for i, text_info in enumerate(extracted_texts[:5]):
        print(f"{i+1}. {text_info.key}: '{text_info.text}'")
        print(f"   文件: {text_info.file_path}:{text_info.line_number}")
        print(f"   上下文: {text_info.context}")
        print()

# 运行演示
if __name__ == "__main__":
    demo_text_extraction()
```

### 2.2 Claude Code集成的翻译工作流

创建智能化的翻译工作流管理系统：

```python
# i18n/workflows/translation_workflow.py
import asyncio
import aiohttp
import json
import time
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import logging
from pathlib import Path

class TranslationProvider(Enum):
    """翻译服务提供商"""
    CLAUDE = "claude"
    GOOGLE = "google"
    DEEPL = "deepl"
    AZURE = "azure"
    BAIDU = "baidu"

class TranslationStatus(Enum):
    """翻译状态"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    REVIEWED = "reviewed"
    APPROVED = "approved"

@dataclass
class TranslationTask:
    """翻译任务"""
    id: str
    source_text: str
    target_text: str
    source_locale: str
    target_locale: str
    key: str
    provider: TranslationProvider
    status: TranslationStatus = TranslationStatus.PENDING
    confidence: float = 0.0
    context: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    error_message: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class TranslationJob:
    """翻译作业"""
    id: str
    name: str
    source_locale: str
    target_locales: List[str]
    tasks: List[TranslationTask] = field(default_factory=list)
    status: TranslationStatus = TranslationStatus.PENDING
    created_at: datetime = field(default_factory=datetime.now)
    progress: float = 0.0

class ClaudeTranslationProvider:
    """Claude翻译提供商"""
    
    def __init__(self, api_key: str, base_url: str = "https://api.anthropic.com/v1"):
        self.api_key = api_key
        self.base_url = base_url
        self.session: Optional[aiohttp.ClientSession] = None
        self.logger = logging.getLogger(__name__)
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def translate_text(self, text: str, source_locale: str, 
                           target_locale: str, context: Optional[str] = None) -> Dict[str, Any]:
        """使用Claude进行翻译"""
        if not self.session:
            self.session = aiohttp.ClientSession()
        
        # 构建翻译提示
        prompt = self._build_translation_prompt(text, source_locale, target_locale, context)
        
        headers = {
            "Content-Type": "application/json",
            "x-api-key": self.api_key,
            "anthropic-version": "2023-06-01"
        }
        
        payload = {
            "model": "claude-3-sonnet-20240229",
            "max_tokens": 4000,
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        }
        
        try:
            async with self.session.post(
                f"{self.base_url}/messages",
                headers=headers,
                json=payload
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    translation_text = result['content'][0]['text']
                    
                    # 解析Claude的响应
                    parsed_result = self._parse_claude_response(translation_text)
                    
                    return {
                        "translated_text": parsed_result.get("translation", translation_text),
                        "confidence": parsed_result.get("confidence", 0.8),
                        "notes": parsed_result.get("notes"),
                        "alternatives": parsed_result.get("alternatives", [])
                    }
                else:
                    error_text = await response.text()
                    raise Exception(f"Claude API错误: {response.status} - {error_text}")
        
        except Exception as e:
            self.logger.error(f"Claude翻译失败: {e}")
            raise
    
    def _build_translation_prompt(self, text: str, source_locale: str, 
                                 target_locale: str, context: Optional[str] = None) -> str:
        """构建翻译提示"""
        locale_names = {
            "en-US": "English",
            "zh-CN": "Simplified Chinese",
            "ja-JP": "Japanese",
            "ko-KR": "Korean",
            "fr-FR": "French",
            "de-DE": "German",
            "es-ES": "Spanish",
            "ar-SA": "Arabic",
            "ru-RU": "Russian",
            "pt-BR": "Portuguese (Brazil)"
        }
        
        source_lang = locale_names.get(source_locale, source_locale)
        target_lang = locale_names.get(target_locale, target_locale)
        
        prompt = f"""请将以下{source_lang}文本翻译成{target_lang}。

要求：
1. 保持原文的语气和风格
2. 确保翻译自然流畅
3. 考虑文化背景和习惯用法
4. 如果是技术术语，保持准确性
5. 提供翻译信心度评分(0-1)

原文: "{text}"
"""
        
        if context:
            prompt += f"\n上下文: {context}\n"
        
        prompt += f"""
请以以下JSON格式回复：
{{
  "translation": "翻译结果",
  "confidence": 0.9,
  "notes": "翻译说明（如有）",
  "alternatives": ["其他可能的翻译选项"]
}}
"""
        
        return prompt
    
    def _parse_claude_response(self, response_text: str) -> Dict[str, Any]:
        """解析Claude的响应"""
        try:
            # 尝试提取JSON部分
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                json_text = json_match.group(0)
                return json.loads(json_text)
        except:
            pass
        
        # 如果无法解析JSON，返回原始文本
        return {
            "translation": response_text.strip(),
            "confidence": 0.7,
            "notes": "Unable to parse structured response",
            "alternatives": []
        }

class TranslationWorkflow:
    """翻译工作流管理器"""
    
    def __init__(self, i18n_core):
        self.i18n_core = i18n_core
        self.providers: Dict[TranslationProvider, Any] = {}
        self.jobs: Dict[str, TranslationJob] = {}
        self.tasks: Dict[str, TranslationTask] = {}
        self.logger = logging.getLogger(__name__)
        
        # 配置
        self.batch_size = 10
        self.max_concurrent_translations = 5
        self.retry_attempts = 3
        self.retry_delay = 2.0
    
    def register_provider(self, provider: TranslationProvider, instance: Any):
        """注册翻译提供商"""
        self.providers[provider] = instance
        self.logger.info(f"已注册翻译提供商: {provider.value}")
    
    async def create_translation_job(self, name: str, source_locale: str, 
                                   target_locales: List[str], 
                                   keys: List[str]) -> str:
        """创建翻译作业"""
        job_id = f"job_{int(time.time())}_{len(self.jobs)}"
        
        job = TranslationJob(
            id=job_id,
            name=name,
            source_locale=source_locale,
            target_locales=target_locales
        )
        
        # 创建翻译任务
        for target_locale in target_locales:
            for key in keys:
                source_text = self.i18n_core.translate(key, source_locale)
                if source_text and source_text != key:  # 确保有源文本
                    task_id = f"task_{job_id}_{target_locale}_{key}"
                    
                    task = TranslationTask(
                        id=task_id,
                        source_text=source_text,
                        target_text="",
                        source_locale=source_locale,
                        target_locale=target_locale,
                        key=key,
                        provider=TranslationProvider.CLAUDE  # 默认使用Claude
                    )
                    
                    job.tasks.append(task)
                    self.tasks[task_id] = task
        
        self.jobs[job_id] = job
        self.logger.info(f"创建翻译作业: {job_id}, 包含 {len(job.tasks)} 个任务")
        
        return job_id
    
    async def execute_job(self, job_id: str) -> bool:
        """执行翻译作业"""
        if job_id not in self.jobs:
            self.logger.error(f"作业不存在: {job_id}")
            return False
        
        job = self.jobs[job_id]
        job.status = TranslationStatus.IN_PROGRESS
        
        try:
            # 按目标语言分组任务
            tasks_by_locale = {}
            for task in job.tasks:
                if task.target_locale not in tasks_by_locale:
                    tasks_by_locale[task.target_locale] = []
                tasks_by_locale[task.target_locale].append(task)
            
            # 并行执行不同语言的翻译
            semaphore = asyncio.Semaphore(self.max_concurrent_translations)
            tasks = []
            
            for target_locale, locale_tasks in tasks_by_locale.items():
                task = self._translate_locale_batch(semaphore, locale_tasks)
                tasks.append(task)
            
            # 等待所有翻译完成
            await asyncio.gather(*tasks, return_exceptions=True)
            
            # 更新作业状态
            completed_tasks = len([t for t in job.tasks if t.status == TranslationStatus.COMPLETED])
            job.progress = completed_tasks / len(job.tasks) * 100
            
            if completed_tasks == len(job.tasks):
                job.status = TranslationStatus.COMPLETED
            else:
                job.status = TranslationStatus.FAILED
            
            self.logger.info(f"作业执行完成: {job_id}, 进度: {job.progress:.1f}%")
            return True
        
        except Exception as e:
            job.status = TranslationStatus.FAILED
            self.logger.error(f"作业执行失败 {job_id}: {e}")
            return False
    
    async def _translate_locale_batch(self, semaphore: asyncio.Semaphore, 
                                    tasks: List[TranslationTask]):
        """翻译特定语言的批次任务"""
        async with semaphore:
            for task in tasks:
                await self._execute_translation_task(task)
    
    async def _execute_translation_task(self, task: TranslationTask):
        """执行单个翻译任务"""
        provider = self.providers.get(task.provider)
        if not provider:
            task.status = TranslationStatus.FAILED
            task.error_message = f"翻译提供商未找到: {task.provider.value}"
            return
        
        task.status = TranslationStatus.IN_PROGRESS
        
        for attempt in range(self.retry_attempts):
            try:
                # 执行翻译
                result = await provider.translate_text(
                    task.source_text,
                    task.source_locale,
                    task.target_locale,
                    task.context
                )
                
                # 更新任务结果
                task.target_text = result["translated_text"]
                task.confidence = result.get("confidence", 0.8)
                task.status = TranslationStatus.COMPLETED
                task.completed_at = datetime.now()
                task.metadata.update({
                    "notes": result.get("notes"),
                    "alternatives": result.get("alternatives", []),
                    "attempt": attempt + 1
                })
                
                # 自动添加到i18n系统
                self.i18n_core.add_translation(
                    task.key,
                    task.target_text,
                    task.target_locale,
                    context=task.context,
                    description=f"Auto-translated by {task.provider.value}"
                )
                
                self.logger.debug(f"翻译任务完成: {task.id}")
                return
            
            except Exception as e:
                self.logger.warning(f"翻译任务失败 {task.id} (尝试 {attempt + 1}): {e}")
                
                if attempt < self.retry_attempts - 1:
                    await asyncio.sleep(self.retry_delay * (attempt + 1))
                else:
                    task.status = TranslationStatus.FAILED
                    task.error_message = str(e)
    
    def get_job_status(self, job_id: str) -> Optional[Dict[str, Any]]:
        """获取作业状态"""
        if job_id not in self.jobs:
            return None
        
        job = self.jobs[job_id]
        
        # 统计任务状态
        status_counts = {}
        for task in job.tasks:
            status = task.status.value
            status_counts[status] = status_counts.get(status, 0) + 1
        
        return {
            "id": job.id,
            "name": job.name,
            "status": job.status.value,
            "progress": job.progress,
            "total_tasks": len(job.tasks),
            "task_status_counts": status_counts,
            "created_at": job.created_at.isoformat(),
            "source_locale": job.source_locale,
            "target_locales": job.target_locales
        }
    
    def get_translation_statistics(self) -> Dict[str, Any]:
        """获取翻译统计信息"""
        total_jobs = len(self.jobs)
        total_tasks = len(self.tasks)
        
        # 按状态统计作业
        job_status_counts = {}
        for job in self.jobs.values():
            status = job.status.value
            job_status_counts[status] = job_status_counts.get(status, 0) + 1
        
        # 按状态统计任务
        task_status_counts = {}
        for task in self.tasks.values():
            status = task.status.value
            task_status_counts[status] = task_status_counts.get(status, 0) + 1
        
        # 按语言统计
        locale_counts = {}
        for task in self.tasks.values():
            locale = task.target_locale
            locale_counts[locale] = locale_counts.get(locale, 0) + 1
        
        # 平均置信度
        completed_tasks = [t for t in self.tasks.values() if t.status == TranslationStatus.COMPLETED]
        avg_confidence = sum(t.confidence for t in completed_tasks) / len(completed_tasks) if completed_tasks else 0
        
        return {
            "summary": {
                "total_jobs": total_jobs,
                "total_tasks": total_tasks,
                "completed_tasks": len(completed_tasks),
                "average_confidence": avg_confidence
            },
            "job_status_distribution": job_status_counts,
            "task_status_distribution": task_status_counts,
            "locale_distribution": locale_counts,
            "providers_used": [p.value for p in self.providers.keys()]
        }
    
    async def export_translations(self, job_id: str, output_dir: str) -> bool:
        """导出翻译结果"""
        if job_id not in self.jobs:
            self.logger.error(f"作业不存在: {job_id}")
            return False
        
        job = self.jobs[job_id]
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        try:
            # 按语言分组导出
            for target_locale in job.target_locales:
                locale_translations = {}
                
                for task in job.tasks:
                    if (task.target_locale == target_locale and 
                        task.status == TranslationStatus.COMPLETED):
                        locale_translations[task.key] = {
                            "value": task.target_text,
                            "context": task.context,
                            "confidence": task.confidence,
                            "source": task.source_text,
                            "provider": task.provider.value,
                            "notes": task.metadata.get("notes"),
                            "alternatives": task.metadata.get("alternatives", [])
                        }
                
                # 保存到文件
                output_file = output_path / f"{target_locale}.json"
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(locale_translations, f, ensure_ascii=False, indent=2)
                
                self.logger.info(f"已导出 {target_locale} 翻译到 {output_file}")
            
            return True
        
        except Exception as e:
            self.logger.error(f"导出翻译失败 {job_id}: {e}")
            return False

# 集成示例
async def demo_translation_workflow():
    """演示翻译工作流"""
    # 初始化i18n系统
    from i18n.core.internationalization import i18n
    
    # 添加源语言内容
    i18n.add_translation("welcome", "Welcome to our application", "en-US")
    i18n.add_translation("login", "Please log in", "en-US")
    i18n.add_translation("error_404", "Page not found", "en-US")
    i18n.add_translation("save_success", "Data saved successfully", "en-US")
    
    # 创建翻译工作流
    workflow = TranslationWorkflow(i18n)
    
    # 注册Claude翻译提供商（需要实际的API密钥）
    # claude_provider = ClaudeTranslationProvider("your-api-key")
    # workflow.register_provider(TranslationProvider.CLAUDE, claude_provider)
    
    # 模拟翻译提供商（用于演示）
    class MockTranslationProvider:
        async def translate_text(self, text, source_locale, target_locale, context=None):
            # 简单的模拟翻译
            translations = {
                "zh-CN": {
                    "Welcome to our application": "欢迎使用我们的应用程序",
                    "Please log in": "请登录",
                    "Page not found": "页面未找到",
                    "Data saved successfully": "数据保存成功"
                }
            }
            
            translated = translations.get(target_locale, {}).get(text, f"[{target_locale}] {text}")
            
            await asyncio.sleep(0.1)  # 模拟API延迟
            
            return {
                "translated_text": translated,
                "confidence": 0.9,
                "notes": "Mock translation",
                "alternatives": []
            }
    
    mock_provider = MockTranslationProvider()
    workflow.register_provider(TranslationProvider.CLAUDE, mock_provider)
    
    # 创建翻译作业
    job_id = await workflow.create_translation_job(
        name="Initial Translation Job",
        source_locale="en-US",
        target_locales=["zh-CN", "ja-JP"],
        keys=["welcome", "login", "error_404", "save_success"]
    )
    
    print(f"创建的翻译作业ID: {job_id}")
    
    # 执行作业
    success = await workflow.execute_job(job_id)
    print(f"作业执行结果: {success}")
    
    # 获取作业状态
    status = workflow.get_job_status(job_id)
    print("作业状态:")
    print(json.dumps(status, indent=2, ensure_ascii=False))
    
    # 获取统计信息
    stats = workflow.get_translation_statistics()
    print("\n翻译统计:")
    print(json.dumps(stats, indent=2, ensure_ascii=False))
    
    # 测试翻译结果
    print("\n翻译结果测试:")
    for locale in ["zh-CN", "ja-JP"]:
        i18n.set_locale(locale)
        print(f"\n{locale}:")
        print(f"welcome: {i18n.translate('welcome')}")
        print(f"login: {i18n.translate('login')}")
        print(f"error_404: {i18n.translate('error_404')}")

# 运行演示
if __name__ == "__main__":
    asyncio.run(demo_translation_workflow())
```

## 多语言文本管理系统

### 3.1 动态内容管理

实现支持动态内容和复杂文本结构的管理系统：

```python
# i18n/content/dynamic_content.py
import json
import re
import yaml
from typing import Dict, List, Any, Optional, Union, Callable
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
import logging
from jinja2 import Template, Environment, BaseLoader

@dataclass
class ContentTemplate:
    """内容模板"""
    id: str
    name: str
    template: str
    variables: List[str]
    locales: Dict[str, str] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

@dataclass
class DynamicContent:
    """动态内容"""
    id: str
    template_id: str
    variables: Dict[str, Any]
    locale: str
    rendered_content: str = ""
    cache_key: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)

class DynamicContentManager:
    """动态内容管理器"""
    
    def __init__(self, i18n_core, templates_dir: str = "templates"):
        self.i18n_core = i18n_core
        self.templates_dir = Path(templates_dir)
        self.templates_dir.mkdir(exist_ok=True)
        
        self.templates: Dict[str, ContentTemplate] = {}
        self.rendered_cache: Dict[str, DynamicContent] = {}
        self.jinja_env = Environment(loader=BaseLoader())
        
        self.logger = logging.getLogger(__name__)
        
        # 注册自定义过滤器
        self._register_filters()
        
        # 加载模板
        self.load_all_templates()
    
    def _register_filters(self):
        """注册Jinja2过滤器"""
        @self.jinja_env.filter
        def translate(key, locale=None, **kwargs):
            """翻译过滤器"""
            return self.i18n_core.translate(key, locale, **kwargs)
        
        @self.jinja_env.filter
        def translate_plural(key, count, locale=None, **kwargs):
            """复数翻译过滤器"""
            return self.i18n_core.translate_plural(key, count, locale, **kwargs)
        
        @self.jinja_env.filter
        def format_currency(amount, locale=None):
            """货币格式化过滤器"""
            return self.i18n_core.format_currency(amount, locale)
        
        @self.jinja_env.filter
        def format_date(date_obj, locale=None):
            """日期格式化过滤器"""
            return self.i18n_core.format_date(date_obj, locale)
        
        @self.jinja_env.filter
        def format_number(num, locale=None):
            """数字格式化过滤器"""
            return self.i18n_core.format_number(num, locale)
    
    def create_template(self, template_id: str, name: str, template_content: str,
                       variables: Optional[List[str]] = None, 
                       metadata: Optional[Dict[str, Any]] = None) -> bool:
        """创建内容模板"""
        try:
            # 自动提取模板变量
            if variables is None:
                variables = self._extract_template_variables(template_content)
            
            template = ContentTemplate(
                id=template_id,
                name=name,
                template=template_content,
                variables=variables,
                metadata=metadata or {}
            )
            
            # 验证模板语法
            try:
                Template(template_content)
            except Exception as e:
                self.logger.error(f"模板语法错误 {template_id}: {e}")
                return False
            
            self.templates[template_id] = template
            
            # 保存到文件
            self._save_template(template)
            
            self.logger.info(f"创建内容模板: {template_id}")
            return True
        
        except Exception as e:
            self.logger.error(f"创建模板失败 {template_id}: {e}")
            return False
    
    def _extract_template_variables(self, template_content: str) -> List[str]:
        """提取模板变量"""
        # 提取Jinja2变量: {{ variable }}
        jinja_vars = re.findall(r'\{\{\s*([a-zA-Z_][a-zA-Z0-9_.]*)\s*\}\}', template_content)
        
        # 提取Jinja2过滤器变量: {{ variable|filter }}
        filter_vars = re.findall(r'\{\{\s*([a-zA-Z_][a-zA-Z0-9_.]*)\s*\|', template_content)
        
        # 提取for循环变量: {% for item in items %}
        for_vars = re.findall(r'\{\%\s*for\s+\w+\s+in\s+([a-zA-Z_][a-zA-Z0-9_.]*)\s*\%\}', template_content)
        
        # 合并并去重
        all_vars = list(set(jinja_vars + filter_vars + for_vars))
        
        # 过滤掉一些内置变量和函数
        builtin_vars = {'loop', 'range', 'translate', 'format_currency', 'format_date', 'format_number'}
        variables = [var for var in all_vars if var.split('.')[0] not in builtin_vars]
        
        return variables
    
    def add_template_locale(self, template_id: str, locale: str, localized_template: str) -> bool:
        """为模板添加本地化版本"""
        if template_id not in self.templates:
            self.logger.error(f"模板不存在: {template_id}")
            return False
        
        try:
            # 验证本地化模板语法
            Template(localized_template)
            
            template = self.templates[template_id]
            template.locales[locale] = localized_template
            template.updated_at = datetime.now()
            
            # 保存更新
            self._save_template(template)
            
            self.logger.info(f"为模板 {template_id} 添加 {locale} 本地化")
            return True
        
        except Exception as e:
            self.logger.error(f"添加模板本地化失败 {template_id} ({locale}): {e}")
            return False
    
    def render_content(self, template_id: str, variables: Dict[str, Any],
                      locale: Optional[str] = None) -> Optional[str]:
        """渲染动态内容"""
        if template_id not in self.templates:
            self.logger.error(f"模板不存在: {template_id}")
            return None
        
        template_obj = self.templates[template_id]
        target_locale = locale or self.i18n_core.current_locale
        
        try:
            # 选择合适的模板内容
            if target_locale in template_obj.locales:
                template_content = template_obj.locales[target_locale]
            else:
                template_content = template_obj.template
            
            # 设置渲染上下文
            context = variables.copy()
            context['locale'] = target_locale
            context['current_locale'] = self.i18n_core.get_current_locale()
            
            # 渲染模板
            template = self.jinja_env.from_string(template_content)
            rendered_content = template.render(**context)
            
            # 缓存结果
            content_id = f"{template_id}_{target_locale}_{hash(str(variables))}"
            self.rendered_cache[content_id] = DynamicContent(
                id=content_id,
                template_id=template_id,
                variables=variables,
                locale=target_locale,
                rendered_content=rendered_content
            )
            
            return rendered_content
        
        except Exception as e:
            self.logger.error(f"渲染内容失败 {template_id}: {e}")
            return None
    
    def render_email_template(self, template_id: str, recipient_data: Dict[str, Any],
                            locale: Optional[str] = None) -> Optional[Dict[str, str]]:
        """渲染邮件模板"""
        content = self.render_content(template_id, recipient_data, locale)
        if not content:
            return None
        
        # 分离邮件主题和正文（假设模板包含Subject:行）
        lines = content.split('\n')
        subject = ""
        body_lines = []
        
        for line in lines:
            if line.startswith('Subject:'):
                subject = line[8:].strip()
            elif line.strip() or body_lines:  # 跳过开头的空行
                body_lines.append(line)
        
        return {
            'subject': subject,
            'body': '\n'.join(body_lines).strip()
        }
    
    def _save_template(self, template: ContentTemplate):
        """保存模板到文件"""
        template_file = self.templates_dir / f"{template.id}.yaml"
        
        data = {
            'id': template.id,
            'name': template.name,
            'template': template.template,
            'variables': template.variables,
            'locales': template.locales,
            'metadata': template.metadata,
            'created_at': template.created_at.isoformat(),
            'updated_at': template.updated_at.isoformat()
        }
        
        with open(template_file, 'w', encoding='utf-8') as f:
            yaml.dump(data, f, allow_unicode=True, indent=2)
    
    def load_template(self, template_file: Path) -> bool:
        """从文件加载模板"""
        try:
            with open(template_file, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            template = ContentTemplate(
                id=data['id'],
                name=data['name'],
                template=data['template'],
                variables=data.get('variables', []),
                locales=data.get('locales', {}),
                metadata=data.get('metadata', {}),
                created_at=datetime.fromisoformat(data.get('created_at', datetime.now().isoformat())),
                updated_at=datetime.fromisoformat(data.get('updated_at', datetime.now().isoformat()))
            )
            
            self.templates[template.id] = template
            return True
        
        except Exception as e:
            self.logger.error(f"加载模板失败 {template_file}: {e}")
            return False
    
    def load_all_templates(self):
        """加载所有模板文件"""
        if not self.templates_dir.exists():
            return
        
        for template_file in self.templates_dir.glob("*.yaml"):
            self.load_template(template_file)
        
        self.logger.info(f"加载了 {len(self.templates)} 个模板")
    
    def get_template_info(self, template_id: str) -> Optional[Dict[str, Any]]:
        """获取模板信息"""
        if template_id not in self.templates:
            return None
        
        template = self.templates[template_id]
        
        return {
            'id': template.id,
            'name': template.name,
            'variables': template.variables,
            'supported_locales': list(template.locales.keys()),
            'metadata': template.metadata,
            'created_at': template.created_at.isoformat(),
            'updated_at': template.updated_at.isoformat()
        }
    
    def list_templates(self) -> List[Dict[str, Any]]:
        """列出所有模板"""
        return [self.get_template_info(template_id) for template_id in self.templates]
    
    def validate_template_variables(self, template_id: str, 
                                  variables: Dict[str, Any]) -> Dict[str, Any]:
        """验证模板变量"""
        if template_id not in self.templates:
            return {"valid": False, "error": "模板不存在"}
        
        template = self.templates[template_id]
        required_vars = set(template.variables)
        provided_vars = set(variables.keys())
        
        missing_vars = required_vars - provided_vars
        extra_vars = provided_vars - required_vars
        
        return {
            "valid": len(missing_vars) == 0,
            "required_variables": list(required_vars),
            "provided_variables": list(provided_vars),
            "missing_variables": list(missing_vars),
            "extra_variables": list(extra_vars)
        }

# 智能内容生成器
class IntelligentContentGenerator:
    """智能内容生成器"""
    
    def __init__(self, dynamic_content_manager: DynamicContentManager):
        self.content_manager = dynamic_content_manager
        self.logger = logging.getLogger(__name__)
    
    def generate_notification_content(self, notification_type: str, 
                                    user_data: Dict[str, Any],
                                    locale: Optional[str] = None) -> Optional[str]:
        """生成通知内容"""
        template_mapping = {
            'welcome': 'notification_welcome',
            'password_reset': 'notification_password_reset',
            'order_confirmation': 'notification_order_confirmation',
            'shipping_update': 'notification_shipping_update',
            'account_suspended': 'notification_account_suspended'
        }
        
        template_id = template_mapping.get(notification_type)
        if not template_id:
            self.logger.error(f"不支持的通知类型: {notification_type}")
            return None
        
        return self.content_manager.render_content(template_id, user_data, locale)
    
    def generate_error_message(self, error_code: str, context: Dict[str, Any],
                             locale: Optional[str] = None) -> str:
        """生成错误消息"""
        # 尝试使用动态模板
        template_id = f"error_{error_code}"
        
        content = self.content_manager.render_content(template_id, context, locale)
        if content:
            return content
        
        # 回退到静态翻译
        i18n = self.content_manager.i18n_core
        fallback_key = f"error.{error_code}"
        
        return i18n.translate(fallback_key, locale, default=f"Error {error_code}")
    
    def generate_multilingual_content(self, template_id: str, 
                                    variables: Dict[str, Any],
                                    target_locales: List[str]) -> Dict[str, str]:
        """生成多语言内容"""
        results = {}
        
        for locale in target_locales:
            content = self.content_manager.render_content(template_id, variables, locale)
            if content:
                results[locale] = content
            else:
                self.logger.warning(f"生成 {locale} 内容失败: {template_id}")
        
        return results

# 使用示例
def demo_dynamic_content():
    """演示动态内容管理"""
    from i18n.core.internationalization import i18n
    
    # 创建动态内容管理器
    content_manager = DynamicContentManager(i18n)
    
    # 创建欢迎邮件模板
    welcome_template = """Subject: {{ 'email.welcome.subject'|translate(user_name=user_name) }}

{{ 'email.welcome.greeting'|translate(user_name=user_name) }}

{{ 'email.welcome.body'|translate }}

{% if has_discount %}
{{ 'email.welcome.discount'|translate(discount_percent=discount_percent) }}
{% endif %}

{{ 'email.welcome.footer'|translate }}
"""
    
    content_manager.create_template(
        "welcome_email",
        "Welcome Email Template",
        welcome_template,
        variables=["user_name", "has_discount", "discount_percent"]
    )
    
    # 添加中文本地化
    welcome_template_zh = """Subject: 欢迎使用我们的服务，{{ user_name }}！

亲爱的 {{ user_name }}，

欢迎加入我们的平台！我们很高兴为您服务。

{% if has_discount %}
作为新用户，您可以享受 {{ discount_percent }}% 的折扣！
{% endif %}

如有任何问题，请随时联系我们。

此致
客服团队
"""
    
    content_manager.add_template_locale("welcome_email", "zh-CN", welcome_template_zh)
    
    # 添加相关翻译
    i18n.add_translation("email.welcome.subject", "Welcome to our service, {user_name}!", "en-US")
    i18n.add_translation("email.welcome.greeting", "Dear {user_name},", "en-US")
    i18n.add_translation("email.welcome.body", "Welcome to our platform! We're excited to have you.", "en-US")
    i18n.add_translation("email.welcome.discount", "As a new user, you get {discount_percent}% discount!", "en-US")
    i18n.add_translation("email.welcome.footer", "Best regards,\nCustomer Service Team", "en-US")
    
    # 渲染内容
    user_data = {
        "user_name": "John Doe",
        "has_discount": True,
        "discount_percent": 20
    }
    
    # 英文版本
    i18n.set_locale("en-US")
    email_en = content_manager.render_email_template("welcome_email", user_data)
    print("英文欢迎邮件:")
    print(f"主题: {email_en['subject']}")
    print(f"内容:\n{email_en['body']}")
    
    # 中文版本
    i18n.set_locale("zh-CN")
    email_zh = content_manager.render_email_template("welcome_email", user_data, "zh-CN")
    print("\n中文欢迎邮件:")
    print(f"主题: {email_zh['subject']}")
    print(f"内容:\n{email_zh['body']}")
    
    # 模板信息
    template_info = content_manager.get_template_info("welcome_email")
    print("\n模板信息:")
    print(json.dumps(template_info, indent=2, ensure_ascii=False))
    
    # 变量验证
    validation = content_manager.validate_template_variables("welcome_email", user_data)
    print("\n变量验证:")
    print(json.dumps(validation, indent=2, ensure_ascii=False))

# 运行演示
if __name__ == "__main__":
    demo_dynamic_content()
```

## 总结

本文全面介绍了使用 Claude Code 进行国际化与本地化实践的完整解决方案，涵盖：

1. **国际化架构设计** - 建立完整的i18n核心系统，支持多语言、多区域
2. **智能文本提取** - 自动从源代码中识别和提取需要翻译的内容
3. **翻译工作流自动化** - 集成Claude AI的智能翻译管道和质量控制
4. **动态内容管理** - 支持模板化的多语言内容生成和管理
5. **文化适配系统** - 处理不同文化背景下的UI和内容调整

通过这些技术和工具，开发者可以：
- 构建真正全球化的应用程序
- 大幅提升翻译效率和质量
- 实现动态、智能的多语言内容管理
- 确保不同文化背景用户的良好体验
- 建立可持续的国际化开发流程

Claude Code 在这个过程中不仅提供了强大的翻译能力，更重要的是帮助开发者建立了系统化、自动化的国际化解决方案，为构建面向全球用户的应用奠定了坚实基础。
```