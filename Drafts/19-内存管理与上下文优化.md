---
layout: post
title: "å†…å­˜ç®¡ç†ä¸ä¸Šä¸‹æ–‡ä¼˜åŒ–ï¼šè®©Claude Codeä¿æŒé•¿æœŸè®°å¿†å’Œé«˜æ•ˆå¯¹è¯"
date: 2025-08-17 03:00:00 +0800
tags: [Claude Code, å†…å­˜ç®¡ç†, ä¸Šä¸‹æ–‡ä¼˜åŒ–, é•¿æœŸè®°å¿†, å¯¹è¯è¿ç»­æ€§]
excerpt: "æ·±å…¥æ¢ç´¢Claude Codeçš„å†…å­˜ç³»ç»ŸåŸç†ï¼Œä»ä¸Šä¸‹æ–‡çª—å£ç®¡ç†åˆ°é•¿æœŸè®°å¿†æœºåˆ¶ï¼ŒæŒæ¡è®©AIåŠ©æ‰‹åœ¨é•¿æœŸé¡¹ç›®ä¸­ä¿æŒä¸€è‡´æ€§å’Œé«˜æ•ˆæ€§çš„æ ¸å¿ƒæŠ€èƒ½ã€‚"
---

## å¼•è¨€ï¼šè®°å¿†æ˜¯æ™ºèƒ½çš„åŸºçŸ³

> "æ²¡æœ‰è®°å¿†ï¼Œå°±æ²¡æœ‰å­¦ä¹ ï¼›æ²¡æœ‰å­¦ä¹ ï¼Œå°±æ²¡æœ‰æ™ºèƒ½ã€‚" â€”â€” Eric Kandel

åœ¨é•¿æœŸçš„è½¯ä»¶å¼€å‘é¡¹ç›®ä¸­ï¼Œ**ä¿æŒä¸Šä¸‹æ–‡çš„è¿ç»­æ€§å’ŒçŸ¥è¯†çš„æŒä¹…æ€§**æ˜¯æˆåŠŸçš„å…³é”®ã€‚Claude Codeçš„å†…å­˜ç®¡ç†ä¸ä¸Šä¸‹æ–‡ä¼˜åŒ–ç³»ç»Ÿæ­£æ˜¯ä¸ºäº†è§£å†³è¿™ä¸€æŒ‘æˆ˜ï¼Œé€šè¿‡æ™ºèƒ½çš„è®°å¿†æœºåˆ¶å’Œä¸Šä¸‹æ–‡ç®¡ç†ï¼Œç¡®ä¿AIåŠ©æ‰‹åœ¨é•¿æœŸåä½œä¸­ä¿æŒä¸€è‡´æ€§å’Œé«˜æ•ˆæ€§ã€‚

è¿™ç¯‡æ–‡ç« å°†å…¨é¢è§£æClaude Codeçš„å†…å­˜ç³»ç»Ÿæ¶æ„ã€ä¸Šä¸‹æ–‡ä¼˜åŒ–ç­–ç•¥ã€é•¿æœŸè®°å¿†æœºåˆ¶ï¼Œä»¥åŠå¦‚ä½•åœ¨å¤æ‚é¡¹ç›®ä¸­å®ç°æ™ºèƒ½åŒ–çš„çŸ¥è¯†ç®¡ç†ã€‚

## å†…å­˜ç³»ç»Ÿæ¶æ„æ¦‚è¿°

### ä¼ ç»ŸAIå¯¹è¯çš„è®°å¿†å±€é™

```
ä¼ ç»ŸAIå¯¹è¯çš„é—®é¢˜ï¼š
1. ä¸Šä¸‹æ–‡çª—å£æœ‰é™ (é€šå¸¸2K-32K tokens)
2. å¯¹è¯ç»“æŸåä¿¡æ¯ä¸¢å¤±
3. æ— æ³•è·¨ä¼šè¯ä¿æŒè®°å¿†
4. ç¼ºä¹é•¿æœŸå­¦ä¹ èƒ½åŠ›
5. é‡å¤ä¿¡æ¯å¯¼è‡´æ•ˆç‡ä½ä¸‹

ç—›ç‚¹ï¼š
- ğŸ§  çŸ­æœŸè®°å¿†ï¼Œé•¿æœŸé—å¿˜
- ğŸ”„ é‡å¤è§£é‡Šç›¸åŒæ¦‚å¿µ
- ğŸ“Š æ— æ³•ç§¯ç´¯é¡¹ç›®çŸ¥è¯†
- â° ä¸Šä¸‹æ–‡é‡å»ºè€—æ—¶
- ğŸ¯ ç¼ºå°‘ä¸ªæ€§åŒ–é€‚åº”
```

### Claude Codeçš„æ™ºèƒ½å†…å­˜ç³»ç»Ÿ

```
å¤šå±‚æ¬¡å†…å­˜æ¶æ„ï¼š
1. å·¥ä½œè®°å¿† (Working Memory) - å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡
2. çŸ­æœŸè®°å¿† (Short-term Memory) - ä¼šè¯å†…çŸ¥è¯†
3. é•¿æœŸè®°å¿† (Long-term Memory) - æŒä¹…åŒ–çŸ¥è¯†åº“
4. é¡¹ç›®è®°å¿† (Project Memory) - é¡¹ç›®ç‰¹å®šä¸Šä¸‹æ–‡
5. ä¸ªäººè®°å¿† (Personal Memory) - ç”¨æˆ·åå¥½å’Œä¹ æƒ¯

ä¼˜åŠ¿ï¼š
- ğŸ§  å¤šå±‚æ¬¡è®°å¿†ç»“æ„
- ğŸ’¾ æŒä¹…åŒ–çŸ¥è¯†å­˜å‚¨
- ğŸ” æ™ºèƒ½ä¿¡æ¯æ£€ç´¢
- ğŸ¯ ä¸Šä¸‹æ–‡è‡ªåŠ¨ç®¡ç†
- ğŸ“ˆ æŒç»­å­¦ä¹ ä¼˜åŒ–
```

## ä¸Šä¸‹æ–‡çª—å£ç®¡ç†

### 1. æ™ºèƒ½ä¸Šä¸‹æ–‡å‹ç¼©

#### åŠ¨æ€ä¿¡æ¯ä¼˜å…ˆçº§

```yaml
# .claude/memory/context-management.yml
context_management:
  window_size: 
    max_tokens: 200000
    optimal_tokens: 150000
    compression_threshold: 180000
    
  priority_levels:
    critical: 1.0      # å½“å‰ä»»åŠ¡ä¸Šä¸‹æ–‡
    high: 0.8         # è¿‘æœŸé‡è¦ä¿¡æ¯
    medium: 0.6       # ç›¸å…³èƒŒæ™¯ä¿¡æ¯
    low: 0.4          # å†å²å‚è€ƒä¿¡æ¯
    archive: 0.2      # å½’æ¡£ä¿¡æ¯
    
  compression_strategies:
    
    - strategy: "semantic_summarization"
      trigger: "token_count > compression_threshold"
      target: "medium and low priority content"
      method: |
        # è¯­ä¹‰æ‘˜è¦å‹ç¼©
        function semanticCompress(content, targetRatio = 0.3) {
          const keyPoints = extractKeyPoints(content);
          const relationships = analyzeRelationships(keyPoints);
          const summary = generateSummary(keyPoints, relationships);
          
          return {
            original_length: content.length,
            compressed_length: summary.length,
            compression_ratio: summary.length / content.length,
            key_concepts: keyPoints,
            summary: summary
          };
        }
    
    - strategy: "hierarchical_abstraction"
      trigger: "context_depth > 5"
      target: "nested conversation threads"
      method: |
        # å±‚æ¬¡åŒ–æŠ½è±¡
        function hierarchicalAbstract(conversations) {
          const hierarchy = buildConversationTree(conversations);
          const abstractions = {};
          
          // ä»å¶å­èŠ‚ç‚¹å‘ä¸ŠæŠ½è±¡
          hierarchy.levels.reverse().forEach(level => {
            level.nodes.forEach(node => {
              if (node.children.length === 0) {
                abstractions[node.id] = summarizeLeafNode(node);
              } else {
                abstractions[node.id] = abstractFromChildren(
                  node.children.map(child => abstractions[child.id])
                );
              }
            });
          });
          
          return abstractions;
        }
    
    - strategy: "temporal_decay"
      trigger: "time_since_last_access > 24h"
      target: "historical information"
      method: |
        # æ—¶é—´è¡°å‡æœºåˆ¶
        function applyTemporalDecay(memoryItems) {
          return memoryItems.map(item => {
            const timeSinceAccess = Date.now() - item.lastAccess;
            const decayFactor = Math.exp(-timeSinceAccess / (24 * 3600 * 1000));
            
            return {
              ...item,
              priority: item.originalPriority * decayFactor,
              decayed: decayFactor < 0.5
            };
          }).filter(item => item.priority > 0.1);
        }

content_preservation:
  always_keep:
    - "current_task_definition"
    - "project_requirements"
    - "user_preferences"
    - "active_code_context"
    - "error_states"
    
  smart_compression:
    - "code_examples" # ä¿ç•™æ ¸å¿ƒé€»è¾‘ï¼Œå‹ç¼©æ³¨é‡Š
    - "conversation_history" # ä¿ç•™å†³ç­–ç‚¹ï¼Œå‹ç¼©è¿‡ç¨‹
    - "documentation" # ä¿ç•™ç»“æ„ï¼Œå‹ç¼©ç»†èŠ‚
    
  lossy_compression:
    - "debug_outputs" # ä»…ä¿ç•™å…³é”®é”™è¯¯
    - "intermediate_steps" # ä»…ä¿ç•™æœ€ç»ˆç»“æœ
    - "redundant_explanations" # å»é‡å¹¶å¼•ç”¨
```

#### ä¸Šä¸‹æ–‡é‡æ„ç®—æ³•

```javascript
// æ™ºèƒ½ä¸Šä¸‹æ–‡é‡æ„å®ç°
class ContextManager {
  constructor() {
    this.maxTokens = 200000;
    this.optimalTokens = 150000;
    this.contextLayers = new Map();
    this.priorityQueue = new PriorityQueue();
  }
  
  // åŠ¨æ€ä¸Šä¸‹æ–‡é‡æ„
  async reconstructContext(currentTokens) {
    if (currentTokens < this.optimalTokens) {
      return this.getCurrentContext();
    }
    
    const compressionPlan = await this.createCompressionPlan(currentTokens);
    const compressedContext = await this.executeCompression(compressionPlan);
    
    return compressedContext;
  }
  
  async createCompressionPlan(currentTokens) {
    const targetTokens = this.optimalTokens;
    const compressionRatio = targetTokens / currentTokens;
    
    const contextItems = await this.analyzeContextItems();
    const plan = {
      totalReduction: currentTokens - targetTokens,
      strategies: []
    };
    
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    contextItems.sort((a, b) => a.priority - b.priority);
    
    let remainingReduction = plan.totalReduction;
    
    for (const item of contextItems) {
      if (remainingReduction <= 0) break;
      
      const strategy = this.selectCompressionStrategy(item);
      const estimatedSaving = this.estimateCompression(item, strategy);
      
      if (estimatedSaving > 0) {
        plan.strategies.push({
          item: item.id,
          strategy: strategy,
          estimatedSaving: estimatedSaving
        });
        
        remainingReduction -= estimatedSaving;
      }
    }
    
    return plan;
  }
  
  selectCompressionStrategy(item) {
    // åŸºäºå†…å®¹ç±»å‹é€‰æ‹©æœ€ä½³å‹ç¼©ç­–ç•¥
    if (item.type === 'code') {
      return 'code_abstraction';
    } else if (item.type === 'conversation') {
      return 'semantic_summarization';
    } else if (item.type === 'documentation') {
      return 'hierarchical_outline';
    } else {
      return 'generic_compression';
    }
  }
  
  async executeCompression(plan) {
    const compressedItems = await Promise.all(
      plan.strategies.map(async strategy => {
        const item = this.contextLayers.get(strategy.item);
        const compressor = this.getCompressor(strategy.strategy);
        
        return compressor.compress(item, strategy.parameters);
      })
    );
    
    return this.rebuiltContextFromCompressed(compressedItems);
  }
}

// è¯­ä¹‰æ„ŸçŸ¥å‹ç¼©å™¨
class SemanticCompressor {
  async compress(content, options = {}) {
    const semanticUnits = await this.extractSemanticUnits(content);
    const importanceScores = await this.scoreImportance(semanticUnits);
    const clusters = await this.clusterSimilarConcepts(semanticUnits);
    
    const compressed = await this.generateCompressedVersion({
      units: semanticUnits,
      scores: importanceScores,
      clusters: clusters,
      targetRatio: options.compressionRatio || 0.3
    });
    
    return {
      original: content,
      compressed: compressed,
      metadata: {
        compressionRatio: compressed.length / content.length,
        preservedConcepts: this.extractPreservedConcepts(compressed),
        recoveryHints: this.generateRecoveryHints(content, compressed)
      }
    };
  }
  
  async extractSemanticUnits(content) {
    // æå–è¯­ä¹‰å•å…ƒï¼šå‡½æ•°ã€ç±»ã€æ¦‚å¿µã€å…³ç³»ç­‰
    const units = [];
    
    // ä»£ç è¯­ä¹‰å•å…ƒ
    if (this.isCode(content)) {
      units.push(...this.extractCodeStructures(content));
    }
    
    // è‡ªç„¶è¯­è¨€è¯­ä¹‰å•å…ƒ
    if (this.isNaturalLanguage(content)) {
      units.push(...this.extractNLPUnits(content));
    }
    
    // æ··åˆå†…å®¹å¤„ç†
    if (this.isMixedContent(content)) {
      units.push(...this.extractMixedUnits(content));
    }
    
    return units;
  }
  
  async scoreImportance(semanticUnits) {
    return semanticUnits.map(unit => {
      let score = 0;
      
      // é¢‘ç‡æƒé‡
      score += unit.frequency * 0.2;
      
      // ä½ç½®æƒé‡
      score += unit.position === 'beginning' ? 0.3 : 0.1;
      
      // å¼•ç”¨æƒé‡  
      score += unit.references * 0.2;
      
      // å¤æ‚åº¦æƒé‡
      score += Math.min(unit.complexity / 10, 0.3);
      
      // æ–°è¿‘æ€§æƒé‡
      const timeFactor = Math.exp(-(Date.now() - unit.timestamp) / (24 * 3600 * 1000));
      score += timeFactor * 0.2;
      
      return {
        ...unit,
        importance: Math.min(score, 1.0)
      };
    });
  }
}
```

### 2. é¡¹ç›®ä¸Šä¸‹æ–‡æŒä¹…åŒ–

#### é¡¹ç›®è®°å¿†ç»“æ„

```yaml
# .claude/memory/project-memory.yml
project_memory_schema:
  
  project_metadata:
    id: "string"
    name: "string"
    type: "web_app | mobile_app | library | service"
    created_at: "timestamp"
    last_active: "timestamp"
    tech_stack:
      frontend: ["react", "typescript", "tailwindcss"]
      backend: ["node.js", "express", "postgresql"]
      tools: ["docker", "jest", "eslint"]
    
  codebase_context:
    file_structure:
      mapping: "file_path -> metadata"
      metadata:
        type: "component | service | utility | config"
        dependencies: ["file_paths"]
        exports: ["symbol_names"]
        last_modified: "timestamp"
        complexity_score: "number"
    
    architectural_patterns:
      - pattern: "mvc"
        locations: ["src/controllers/", "src/models/", "src/views/"]
        conventions: ["naming", "structure", "relationships"]
      
      - pattern: "component_composition"
        locations: ["src/components/"]
        conventions: ["props_interface", "hook_usage", "styling"]
    
    code_conventions:
      naming:
        files: "kebab-case"
        functions: "camelCase"
        components: "PascalCase"
        constants: "SCREAMING_SNAKE_CASE"
      
      structure:
        component_structure: ["props_interface", "component", "styles", "tests"]
        service_structure: ["interface", "implementation", "tests"]
        
  development_history:
    decisions:
      - decision_id: "uuid"
        date: "timestamp"
        title: "string"
        context: "string"
        options_considered: ["option_list"]
        chosen_option: "string"
        rationale: "string"
        consequences: ["string_list"]
        
    patterns_learned:
      - pattern_id: "uuid"
        name: "string" 
        context: "when this pattern applies"
        implementation: "how to implement"
        pros_cons: ["advantages and disadvantages"]
        examples: ["code_examples"]
        
    common_issues:
      - issue_id: "uuid"
        title: "string"
        description: "string"
        symptoms: ["how to recognize"]
        solutions: ["how to fix"]
        prevention: ["how to avoid"]
        
  user_preferences:
    coding_style:
      indentation: "spaces | tabs"
      quote_style: "single | double"
      semicolons: "always | never"
      trailing_commas: "always | never"
      
    workflow_preferences:
      test_first: "boolean"
      commit_frequency: "often | milestone"
      code_review_style: "thorough | quick"
      
    communication_style:
      detail_level: "brief | detailed | comprehensive"
      explanation_style: "conceptual | practical | mixed"
      error_handling: "show_full_trace | summarize | focus_on_fix"

memory_persistence:
  
  storage_layers:
    - layer: "session_cache"
      duration: "current_session"
      content: ["active_context", "recent_changes"]
      
    - layer: "project_database"
      duration: "project_lifetime"
      content: ["codebase_structure", "decisions", "patterns"]
      
    - layer: "long_term_knowledge"
      duration: "permanent"
      content: ["general_patterns", "best_practices", "user_model"]
      
  synchronization:
    triggers:
      - "session_end"
      - "major_milestone"
      - "context_switch"
      - "explicit_save_command"
      
    conflict_resolution:
      strategy: "timestamp_priority"
      backup: "version_history"
      
  compression_schedule:
    immediate: ["debug_logs", "temporary_files"]
    daily: ["detailed_conversations", "intermediate_steps"]  
    weekly: ["historical_contexts", "superseded_decisions"]
    monthly: ["archived_projects", "outdated_patterns"]
```

#### æ™ºèƒ½é¡¹ç›®æ¢å¤

```javascript
// é¡¹ç›®ä¸Šä¸‹æ–‡æ™ºèƒ½æ¢å¤ç³»ç»Ÿ
class ProjectContextRecovery {
  constructor() {
    this.memoryDatabase = new ProjectMemoryDB();
    this.contextBuilder = new ContextBuilder();
    this.relevanceAnalyzer = new RelevanceAnalyzer();
  }
  
  async recoverProjectContext(projectId, currentTask) {
    console.log(`ğŸ”„ æ¢å¤é¡¹ç›®ä¸Šä¸‹æ–‡: ${projectId}`);
    
    const recoveryPlan = await this.createRecoveryPlan(projectId, currentTask);
    const contextLayers = await this.buildContextLayers(recoveryPlan);
    const optimizedContext = await this.optimizeContext(contextLayers);
    
    return optimizedContext;
  }
  
  async createRecoveryPlan(projectId, currentTask) {
    const projectMeta = await this.memoryDatabase.getProjectMetadata(projectId);
    const taskRelevance = await this.analyzeTaskRelevance(currentTask, projectMeta);
    
    return {
      priority_contexts: [
        // å½“å‰ä»»åŠ¡ç›´æ¥ç›¸å…³
        ...taskRelevance.directlyRelevant,
        // æ¶æ„å’Œè®¾è®¡å†³ç­–
        ...await this.getArchitecturalContext(projectId),
        // è¿‘æœŸå¼€å‘å†å²
        ...await this.getRecentHistory(projectId, '7d'),
        // ç”¨æˆ·åå¥½å’Œçº¦å®š
        ...await this.getUserPreferences(projectId)
      ],
      
      background_contexts: [
        // é¡¹ç›®æ•´ä½“ç»“æ„
        ...await this.getProjectStructure(projectId),
        // æŠ€æœ¯æ ˆä¿¡æ¯
        ...await this.getTechStackContext(projectId),
        // å†å²å†³ç­–è®°å½•
        ...await this.getHistoricalDecisions(projectId)
      ],
      
      reference_contexts: [
        // ç›¸ä¼¼é¡¹ç›®ç»éªŒ
        ...await this.getSimilarProjectInsights(projectMeta),
        // é€šç”¨æœ€ä½³å®è·µ
        ...await this.getBestPractices(projectMeta.techStack)
      ]
    };
  }
  
  async buildContextLayers(recoveryPlan) {
    const layers = {};
    
    // æ„å»ºä¼˜å…ˆçº§ä¸Šä¸‹æ–‡å±‚
    layers.priority = await this.buildPriorityLayer(recoveryPlan.priority_contexts);
    layers.background = await this.buildBackgroundLayer(recoveryPlan.background_contexts);
    layers.reference = await this.buildReferenceLayer(recoveryPlan.reference_contexts);
    
    return layers;
  }
  
  async buildPriorityLayer(contexts) {
    const layer = {
      current_task: {},
      relevant_code: {},
      recent_decisions: {},
      active_patterns: {}
    };
    
    for (const context of contexts) {
      switch (context.type) {
        case 'current_file':
          layer.current_task.file_context = await this.expandFileContext(context);
          break;
          
        case 'related_components':
          layer.relevant_code.components = await this.expandComponentContext(context);
          break;
          
        case 'recent_decision':
          layer.recent_decisions[context.id] = await this.expandDecisionContext(context);
          break;
          
        case 'active_pattern':
          layer.active_patterns[context.pattern] = await this.expandPatternContext(context);
          break;
      }
    }
    
    return layer;
  }
  
  async optimizeContext(contextLayers) {
    // è®¡ç®—å½“å‰tokenä½¿ç”¨é‡
    const currentSize = this.calculateContextSize(contextLayers);
    
    if (currentSize <= this.maxTokens) {
      return contextLayers;
    }
    
    // éœ€è¦ä¼˜åŒ–
    console.log(`ğŸ“Š ä¸Šä¸‹æ–‡å¤§å°: ${currentSize} tokens, éœ€è¦ä¼˜åŒ–`);
    
    // åº”ç”¨ä¼˜åŒ–ç­–ç•¥
    const optimized = await this.applyOptimizationStrategies(contextLayers, currentSize);
    
    return optimized;
  }
  
  async applyOptimizationStrategies(contextLayers, currentSize) {
    const targetSize = Math.floor(this.maxTokens * 0.8);
    const reductionNeeded = currentSize - targetSize;
    
    let optimizedLayers = { ...contextLayers };
    let currentReduction = 0;
    
    // ç­–ç•¥1: å‹ç¼©å‚è€ƒå±‚
    if (currentReduction < reductionNeeded) {
      const compressed = await this.compressReferenceLayer(optimizedLayers.reference);
      const reduction = this.calculateSizeReduction(optimizedLayers.reference, compressed);
      
      optimizedLayers.reference = compressed;
      currentReduction += reduction;
      console.log(`ğŸ”§ å‚è€ƒå±‚å‹ç¼©: å‡å°‘ ${reduction} tokens`);
    }
    
    // ç­–ç•¥2: æ±‡æ€»èƒŒæ™¯å±‚
    if (currentReduction < reductionNeeded) {
      const summarized = await this.summarizeBackgroundLayer(optimizedLayers.background);
      const reduction = this.calculateSizeReduction(optimizedLayers.background, summarized);
      
      optimizedLayers.background = summarized;
      currentReduction += reduction;
      console.log(`ğŸ“ èƒŒæ™¯å±‚æ±‡æ€»: å‡å°‘ ${reduction} tokens`);
    }
    
    // ç­–ç•¥3: æ™ºèƒ½é‡‡æ ·ä¼˜å…ˆçº§å±‚
    if (currentReduction < reductionNeeded) {
      const sampled = await this.samplePriorityLayer(optimizedLayers.priority, reductionNeeded - currentReduction);
      const reduction = this.calculateSizeReduction(optimizedLayers.priority, sampled);
      
      optimizedLayers.priority = sampled;
      currentReduction += reduction;
      console.log(`ğŸ¯ ä¼˜å…ˆçº§å±‚é‡‡æ ·: å‡å°‘ ${reduction} tokens`);
    }
    
    const finalSize = this.calculateContextSize(optimizedLayers);
    console.log(`âœ… ä¸Šä¸‹æ–‡ä¼˜åŒ–å®Œæˆ: ${currentSize} -> ${finalSize} tokens`);
    
    return optimizedLayers;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
class ClaudeCodeSession {
  async startProject(projectPath) {
    const projectId = this.identifyProject(projectPath);
    const currentTask = this.inferCurrentTask();
    
    console.log(`ğŸš€ å¯åŠ¨é¡¹ç›®ä¼šè¯: ${projectId}`);
    
    // æ¢å¤é¡¹ç›®ä¸Šä¸‹æ–‡
    const context = await this.recovery.recoverProjectContext(projectId, currentTask);
    
    // åº”ç”¨ä¸Šä¸‹æ–‡
    await this.applyContext(context);
    
    console.log(`âœ… é¡¹ç›®ä¸Šä¸‹æ–‡å·²æ¢å¤ï¼Œå¯ä»¥ç»§ç»­å·¥ä½œ`);
    
    return {
      project: projectId,
      contextSize: this.calculateContextSize(context),
      readyForWork: true
    };
  }
}
```

## é•¿æœŸè®°å¿†æœºåˆ¶

### 1. çŸ¥è¯†å›¾è°±æ„å»º

#### æ¦‚å¿µå…³ç³»ç½‘ç»œ

```yaml
# .claude/memory/knowledge-graph.yml
knowledge_graph:
  
  node_types:
    - type: "concept"
      properties: ["name", "definition", "category", "confidence"]
      examples: ["React Hook", "Database Index", "Design Pattern"]
      
    - type: "code_entity"
      properties: ["name", "type", "location", "dependencies", "complexity"]
      examples: ["UserService class", "validateEmail function", "API endpoint"]
      
    - type: "decision"
      properties: ["title", "date", "context", "outcome", "rationale"]
      examples: ["Choose React over Vue", "Use PostgreSQL", "Microservice architecture"]
      
    - type: "pattern"
      properties: ["name", "description", "use_cases", "implementation"]
      examples: ["Observer Pattern", "Repository Pattern", "Component Composition"]
      
    - type: "issue"
      properties: ["title", "symptoms", "cause", "solution", "prevention"]
      examples: ["Memory leak in React app", "Slow database queries", "CORS error"]
  
  relationship_types:
    - type: "depends_on"
      description: "å®ä½“Aä¾èµ–äºå®ä½“B"
      example: "UserComponent depends_on UserService"
      
    - type: "implements"
      description: "å®ä½“Aå®ç°äº†æ¦‚å¿µB"
      example: "UserRepository implements Repository_Pattern"
      
    - type: "caused_by"
      description: "é—®é¢˜Aç”±åŸå› Bå¯¼è‡´"
      example: "Performance_Issue caused_by Inefficient_Query"
      
    - type: "solves"
      description: "è§£å†³æ–¹æ¡ˆAè§£å†³äº†é—®é¢˜B"
      example: "Database_Index solves Slow_Query"
      
    - type: "relates_to"
      description: "æ¦‚å¿µAä¸æ¦‚å¿µBç›¸å…³"
      example: "React_Hooks relates_to Component_State"
      
    - type: "supersedes"
      description: "å†³ç­–Aå–ä»£äº†å†³ç­–B"
      example: "Use_TypeScript supersedes Use_JavaScript"

  graph_construction:
    
    automatic_extraction:
      - trigger: "code_analysis"
        extractor: "ast_analyzer"
        targets: ["functions", "classes", "modules", "dependencies"]
        
      - trigger: "conversation_analysis"
        extractor: "nlp_analyzer" 
        targets: ["concepts", "decisions", "problems", "solutions"]
        
      - trigger: "documentation_parsing"
        extractor: "doc_analyzer"
        targets: ["specifications", "requirements", "patterns"]
    
    relationship_inference:
      - method: "co_occurrence_analysis"
        description: "åŸºäºå…±åŒå‡ºç°é¢‘ç‡æ¨æ–­å…³ç³»"
        threshold: 0.3
        
      - method: "semantic_similarity"
        description: "åŸºäºè¯­ä¹‰ç›¸ä¼¼æ€§æ¨æ–­å…³ç³»"
        threshold: 0.7
        
      - method: "causal_analysis"
        description: "åŸºäºå› æœå…³ç³»æ¨æ–­"
        patterns: ["caused by", "results in", "leads to"]
    
    knowledge_validation:
      - validator: "consistency_checker"
        rules: ["no_circular_dependencies", "valid_relationships"]
        
      - validator: "relevance_scorer"
        factors: ["usage_frequency", "recency", "user_interest"]
        
      - validator: "confidence_estimator"
        sources: ["code_evidence", "documentation", "user_confirmation"]

  graph_operations:
    
    query_patterns:
      - pattern: "find_related_concepts"
        cypher: |
          MATCH (c:Concept)-[:relates_to*1..2]-(related:Concept)
          WHERE c.name = $concept_name
          RETURN related, path
          ORDER BY related.confidence DESC
          
      - pattern: "find_implementation_examples"
        cypher: |
          MATCH (pattern:Pattern)<-[:implements]-(impl:CodeEntity)
          WHERE pattern.name = $pattern_name
          RETURN impl, pattern
          ORDER BY impl.complexity ASC
          
      - pattern: "trace_decision_impact"
        cypher: |
          MATCH (decision:Decision)-[:influences*]->(affected)
          WHERE decision.title = $decision_title
          RETURN affected, path
          ORDER BY path.length ASC
    
    graph_maintenance:
      - operation: "prune_outdated_nodes"
        schedule: "weekly"
        criteria: ["last_access < 30d", "confidence < 0.3"]
        
      - operation: "strengthen_relationships"
        schedule: "daily"
        criteria: ["co_occurrence_frequency", "user_confirmation"]
        
      - operation: "detect_duplicates"
        schedule: "weekly"
        method: "semantic_similarity"
        threshold: 0.9
```

#### çŸ¥è¯†å›¾è°±å®ç°

```javascript
// çŸ¥è¯†å›¾è°±ç®¡ç†ç³»ç»Ÿ
class KnowledgeGraphManager {
  constructor() {
    this.graph = new Neo4jGraph();
    this.conceptExtractor = new ConceptExtractor();
    this.relationshipInferrer = new RelationshipInferrer();
  }
  
  // ä»ä»£ç ä¸­æå–çŸ¥è¯†
  async extractFromCode(codeContent, filePath) {
    const entities = await this.conceptExtractor.extractCodeEntities(codeContent);
    const concepts = await this.conceptExtractor.extractConcepts(codeContent);
    const relationships = await this.relationshipInferrer.inferFromCode(entities, concepts);
    
    return this.updateGraph({
      entities,
      concepts,
      relationships,
      source: { type: 'code', path: filePath, timestamp: Date.now() }
    });
  }
  
  // ä»å¯¹è¯ä¸­æå–çŸ¥è¯†
  async extractFromConversation(conversation) {
    const decisions = await this.conceptExtractor.extractDecisions(conversation);
    const problems = await this.conceptExtractor.extractProblems(conversation);
    const solutions = await this.conceptExtractor.extractSolutions(conversation);
    const concepts = await this.conceptExtractor.extractDiscussedConcepts(conversation);
    
    const relationships = await this.relationshipInferrer.inferFromConversation({
      decisions, problems, solutions, concepts
    });
    
    return this.updateGraph({
      decisions,
      problems, 
      solutions,
      concepts,
      relationships,
      source: { type: 'conversation', timestamp: Date.now() }
    });
  }
  
  // æ™ºèƒ½æŸ¥è¯¢ç›¸å…³çŸ¥è¯†
  async queryRelevantKnowledge(context, maxResults = 10) {
    const queries = await this.generateSmartQueries(context);
    const results = await Promise.all(
      queries.map(query => this.executeQuery(query))
    );
    
    const mergedResults = this.mergeAndRankResults(results);
    return mergedResults.slice(0, maxResults);
  }
  
  async generateSmartQueries(context) {
    const queries = [];
    
    // åŸºäºå½“å‰ä»»åŠ¡çš„ç›´æ¥æŸ¥è¯¢
    if (context.currentTask) {
      queries.push({
        type: 'task_related',
        cypher: `
          MATCH (n)-[:relates_to*1..2]-(related)
          WHERE n.name CONTAINS $taskKeyword
          RETURN related, n
          ORDER BY related.confidence DESC
        `,
        params: { taskKeyword: context.currentTask }
      });
    }
    
    // åŸºäºä»£ç å®ä½“çš„æŸ¥è¯¢
    if (context.codeEntities) {
      queries.push({
        type: 'code_related',
        cypher: `
          MATCH (entity:CodeEntity)-[:depends_on|implements*1..2]-(related)
          WHERE entity.name IN $entityNames
          RETURN related, entity
          ORDER BY related.usage_frequency DESC
        `,
        params: { entityNames: context.codeEntities }
      });
    }
    
    // åŸºäºå†å²é—®é¢˜çš„æŸ¥è¯¢
    if (context.similarIssues) {
      queries.push({
        type: 'issue_related',
        cypher: `
          MATCH (issue:Issue)-[:solves|caused_by]-(related)
          WHERE issue.symptoms CONTAINS ANY($symptoms)
          RETURN related, issue
          ORDER BY issue.resolution_success_rate DESC
        `,
        params: { symptoms: context.similarIssues }
      });
    }
    
    return queries;
  }
  
  // çŸ¥è¯†ç½®ä¿¡åº¦è¯„ä¼°
  async assessKnowledgeConfidence(knowledge) {
    const factors = {
      sourceReliability: this.assessSourceReliability(knowledge.source),
      evidenceStrength: this.assessEvidenceStrength(knowledge.evidence),
      consensusLevel: await this.assessConsensusLevel(knowledge),
      recency: this.assessRecency(knowledge.timestamp),
      usageFrequency: await this.getUsageFrequency(knowledge.id)
    };
    
    const confidence = this.calculateConfidence(factors);
    
    return {
      ...knowledge,
      confidence,
      confidenceFactors: factors
    };
  }
  
  calculateConfidence(factors) {
    const weights = {
      sourceReliability: 0.3,
      evidenceStrength: 0.25,
      consensusLevel: 0.2,
      recency: 0.15,
      usageFrequency: 0.1
    };
    
    return Object.entries(factors).reduce((sum, [factor, value]) => {
      return sum + (value * weights[factor]);
    }, 0);
  }
}

// æ¦‚å¿µæå–å™¨
class ConceptExtractor {
  async extractCodeEntities(code) {
    const ast = this.parseAST(code);
    const entities = [];
    
    // æå–ç±»
    const classes = this.extractClasses(ast);
    entities.push(...classes.map(cls => ({
      type: 'class',
      name: cls.name,
      methods: cls.methods,
      properties: cls.properties,
      dependencies: cls.dependencies,
      complexity: this.calculateComplexity(cls)
    })));
    
    // æå–å‡½æ•°
    const functions = this.extractFunctions(ast);
    entities.push(...functions.map(fn => ({
      type: 'function',
      name: fn.name,
      parameters: fn.parameters,
      returnType: fn.returnType,
      dependencies: fn.dependencies,
      complexity: this.calculateComplexity(fn)
    })));
    
    // æå–æ¥å£
    const interfaces = this.extractInterfaces(ast);
    entities.push(...interfaces.map(iface => ({
      type: 'interface',
      name: iface.name,
      properties: iface.properties,
      methods: iface.methods
    })));
    
    return entities;
  }
  
  async extractDecisions(conversation) {
    const decisionPatterns = [
      /(?:decided to|chose to|will use|going with)\s+([^.!?]+)/gi,
      /(?:decision|choice):\s*([^.!?]+)/gi,
      /(?:we should|let's|I recommend)\s+([^.!?]+)/gi
    ];
    
    const decisions = [];
    
    for (const pattern of decisionPatterns) {
      let match;
      while ((match = pattern.exec(conversation)) !== null) {
        const decision = {
          text: match[1].trim(),
          context: this.extractSurroundingContext(conversation, match.index),
          timestamp: Date.now(),
          confidence: this.assessDecisionConfidence(match[0])
        };
        
        decisions.push(decision);
      }
    }
    
    return this.deduplicateDecisions(decisions);
  }
}
```

### 2. ä¸ªæ€§åŒ–å­¦ä¹ ç³»ç»Ÿ

#### ç”¨æˆ·æ¨¡å¼è¯†åˆ«

```yaml
# .claude/memory/user-model.yml
user_modeling:
  
  behavioral_patterns:
    
    coding_style:
      preferences:
        - metric: "indentation_style"
          values: ["spaces", "tabs"]
          detection: "code_analysis"
          
        - metric: "naming_convention"
          values: ["camelCase", "snake_case", "kebab-case"]
          detection: "identifier_analysis"
          
        - metric: "comment_frequency"
          values: ["verbose", "moderate", "minimal"]
          detection: "comment_ratio_analysis"
          
        - metric: "function_length_preference"
          values: ["short", "medium", "long"]
          detection: "function_length_analysis"
    
    problem_solving_approach:
      - pattern: "test_first_development"
        indicators: ["writes_tests_before_code", "mentions_tdd"]
        confidence_threshold: 0.7
        
      - pattern: "iterative_development"
        indicators: ["incremental_changes", "frequent_commits"]
        confidence_threshold: 0.6
        
      - pattern: "research_oriented"
        indicators: ["asks_for_alternatives", "compares_solutions"]
        confidence_threshold: 0.8
        
      - pattern: "solution_focused"
        indicators: ["direct_implementation_requests", "minimal_explanation_needed"]
        confidence_threshold: 0.7
    
    communication_style:
      - dimension: "detail_preference"
        low_indicators: ["brief_answers", "skip_explanations"]
        high_indicators: ["detailed_explanations", "context_requests"]
        
      - dimension: "technical_depth"
        low_indicators: ["high_level_concepts", "avoid_internals"]
        high_indicators: ["implementation_details", "algorithm_discussions"]
        
      - dimension: "learning_orientation"
        low_indicators: ["just_give_solution", "minimal_questions"]
        high_indicators: ["explain_why", "learning_questions"]

  adaptation_strategies:
    
    response_customization:
      - condition: "user.coding_style.comment_frequency == 'verbose'"
        adaptation: "include_detailed_comments_in_code"
        
      - condition: "user.problem_solving.test_first_development == true"
        adaptation: "provide_tests_before_implementation"
        
      - condition: "user.communication.detail_preference == 'low'"
        adaptation: "concise_responses_with_optional_details"
        
      - condition: "user.technical_depth == 'high'"
        adaptation: "include_implementation_rationale"
    
    proactive_suggestions:
      - trigger: "user_starts_new_feature"
        suggestions: [
          "architecture_considerations",
          "testing_strategy",
          "potential_challenges"
        ]
        
      - trigger: "user_encounters_error"
        suggestions: [
          "similar_past_solutions",
          "debugging_approaches",
          "prevention_strategies"
        ]
        
      - trigger: "user_asks_about_performance"
        suggestions: [
          "profiling_tools",
          "optimization_patterns",
          "benchmarking_approaches"
        ]

  learning_mechanisms:
    
    implicit_feedback:
      - signal: "code_acceptance_rate"
        weight: 0.3
        calculation: "accepted_suggestions / total_suggestions"
        
      - signal: "follow_up_questions"
        weight: 0.2
        calculation: "questions_asked / responses_given"
        
      - signal: "modification_patterns"
        weight: 0.3
        calculation: "user_modifications / suggested_code"
        
      - signal: "session_duration"
        weight: 0.2
        calculation: "average_session_length"
    
    explicit_feedback:
      - mechanism: "rating_system"
        scale: "1-5_stars"
        frequency: "after_major_tasks"
        
      - mechanism: "preference_settings"
        categories: ["communication", "coding_style", "explanation_depth"]
        
      - mechanism: "correction_feedback"
        triggers: ["user_corrects_code", "user_explains_preference"]

  model_evolution:
    
    confidence_updates:
      - method: "bayesian_updating"
        prior_weight: 0.7
        evidence_weight: 0.3
        
      - method: "temporal_decay"
        half_life: "30_days"
        minimum_confidence: 0.1
    
    model_validation:
      - validator: "prediction_accuracy"
        metric: "preference_prediction_success_rate"
        threshold: 0.75
        
      - validator: "consistency_checker"
        metric: "preference_contradiction_rate"
        threshold: 0.1
        
      - validator: "relevance_assessor"
        metric: "suggestion_acceptance_rate"
        threshold: 0.6
```

#### è‡ªé€‚åº”å“åº”ç³»ç»Ÿ

```javascript
// ä¸ªæ€§åŒ–è‡ªé€‚åº”ç³»ç»Ÿ
class PersonalizationEngine {
  constructor() {
    this.userModel = new UserModel();
    this.adaptationStrategies = new AdaptationStrategies();
    this.feedbackProcessor = new FeedbackProcessor();
  }
  
  // ä¸ªæ€§åŒ–å“åº”ç”Ÿæˆ
  async generatePersonalizedResponse(request, context) {
    const userProfile = await this.userModel.getCurrentProfile();
    const adaptations = await this.selectAdaptations(request, userProfile);
    
    let response = await this.generateBaseResponse(request, context);
    response = await this.applyAdaptations(response, adaptations);
    
    // è®°å½•ç”¨äºåç»­å­¦ä¹ 
    this.recordInteraction(request, response, userProfile);
    
    return response;
  }
  
  async selectAdaptations(request, userProfile) {
    const adaptations = [];
    
    // ä»£ç é£æ ¼é€‚åº”
    if (request.type === 'code_generation') {
      adaptations.push(...this.getCodeStyleAdaptations(userProfile));
    }
    
    // è§£é‡Šæ·±åº¦é€‚åº”
    if (request.needsExplanation) {
      adaptations.push(this.getExplanationAdaptation(userProfile));
    }
    
    // æ²Ÿé€šé£æ ¼é€‚åº”
    adaptations.push(this.getCommunicationAdaptation(userProfile));
    
    return adaptations;
  }
  
  getCodeStyleAdaptations(userProfile) {
    const adaptations = [];
    
    // ç¼©è¿›é£æ ¼
    if (userProfile.codingStyle.indentation === 'tabs') {
      adaptations.push({
        type: 'code_formatting',
        rule: 'use_tabs_for_indentation'
      });
    }
    
    // å‘½åçº¦å®š
    if (userProfile.codingStyle.naming === 'snake_case') {
      adaptations.push({
        type: 'naming_convention',
        rule: 'prefer_snake_case'
      });
    }
    
    // æ³¨é‡Šå¯†åº¦
    if (userProfile.codingStyle.commentFrequency === 'verbose') {
      adaptations.push({
        type: 'comment_style',
        rule: 'add_detailed_comments'
      });
    }
    
    return adaptations;
  }
  
  getExplanationAdaptation(userProfile) {
    const detailLevel = userProfile.communication.detailPreference;
    const technicalDepth = userProfile.communication.technicalDepth;
    
    return {
      type: 'explanation_style',
      detailLevel: detailLevel,
      technicalDepth: technicalDepth,
      includeExamples: userProfile.learning.preferExamples,
      includeAlternatives: userProfile.problemSolving.researchOriented
    };
  }
  
  async applyAdaptations(response, adaptations) {
    let adaptedResponse = { ...response };
    
    for (const adaptation of adaptations) {
      switch (adaptation.type) {
        case 'code_formatting':
          adaptedResponse.code = await this.reformatCode(
            adaptedResponse.code, 
            adaptation.rule
          );
          break;
          
        case 'explanation_style':
          adaptedResponse.explanation = await this.adaptExplanation(
            adaptedResponse.explanation,
            adaptation
          );
          break;
          
        case 'communication_style':
          adaptedResponse.tone = this.adaptCommunicationTone(
            adaptedResponse.tone,
            adaptation.style
          );
          break;
      }
    }
    
    return adaptedResponse;
  }
  
  // å­¦ä¹ ç”¨æˆ·åå¥½
  async learnFromFeedback(interaction, feedback) {
    const insights = await this.feedbackProcessor.analyze(interaction, feedback);
    
    for (const insight of insights) {
      await this.userModel.updateProfile(insight.dimension, insight.update);
    }
    
    // éªŒè¯æ¨¡å‹ä¸€è‡´æ€§
    await this.validateModelConsistency();
  }
  
  async validateModelConsistency() {
    const profile = await this.userModel.getCurrentProfile();
    const inconsistencies = this.detectInconsistencies(profile);
    
    if (inconsistencies.length > 0) {
      await this.resolveInconsistencies(inconsistencies);
    }
  }
}

// ç”¨æˆ·æ¨¡å‹ç®¡ç†
class UserModel {
  constructor() {
    this.profile = {
      codingStyle: new Map(),
      communication: new Map(),
      problemSolving: new Map(),
      learning: new Map()
    };
    this.confidence = new Map();
    this.lastUpdated = new Map();
  }
  
  async updateProfile(dimension, update) {
    const current = this.profile[update.category].get(dimension) || 0.5;
    const confidence = this.confidence.get(`${update.category}.${dimension}`) || 0.1;
    
    // è´å¶æ–¯æ›´æ–°
    const newValue = this.bayesianUpdate(current, update.evidence, confidence);
    const newConfidence = Math.min(confidence + update.strength, 1.0);
    
    this.profile[update.category].set(dimension, newValue);
    this.confidence.set(`${update.category}.${dimension}`, newConfidence);
    this.lastUpdated.set(`${update.category}.${dimension}`, Date.now());
    
    await this.persistProfile();
  }
  
  bayesianUpdate(prior, evidence, confidence) {
    const likelihood = this.calculateLikelihood(evidence);
    const posterior = (likelihood * prior * confidence) / 
                     (likelihood * prior * confidence + (1 - likelihood) * (1 - prior) * (1 - confidence));
    
    return Math.max(0.1, Math.min(0.9, posterior));
  }
  
  async getPreference(category, dimension) {
    const value = this.profile[category].get(dimension);
    const confidence = this.confidence.get(`${category}.${dimension}`);
    const lastUpdate = this.lastUpdated.get(`${category}.${dimension}`);
    
    // åº”ç”¨æ—¶é—´è¡°å‡
    const decayedConfidence = this.applyTemporalDecay(confidence, lastUpdate);
    
    return {
      value: value || 0.5,
      confidence: decayedConfidence || 0.1,
      lastUpdated: lastUpdate
    };
  }
}
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ä½¿ç”¨ä¼˜åŒ–

#### æ™ºèƒ½ç¼“å­˜ç®¡ç†

```javascript
// å¤šå±‚ç¼“å­˜ç³»ç»Ÿ
class HierarchicalCache {
  constructor() {
    this.l1Cache = new LRUCache({ max: 100, ttl: 5 * 60 * 1000 }); // 5åˆ†é’Ÿ
    this.l2Cache = new LRUCache({ max: 1000, ttl: 30 * 60 * 1000 }); // 30åˆ†é’Ÿ
    this.l3Cache = new PersistentCache({ max: 10000, ttl: 24 * 60 * 60 * 1000 }); // 24å°æ—¶
    
    this.compressionThreshold = 10000; // 10KB
    this.compressor = new ContextCompressor();
  }
  
  async get(key) {
    // L1ç¼“å­˜æŸ¥æ‰¾
    let value = this.l1Cache.get(key);
    if (value) {
      return this.decompressIfNeeded(value);
    }
    
    // L2ç¼“å­˜æŸ¥æ‰¾
    value = this.l2Cache.get(key);
    if (value) {
      // æå‡åˆ°L1
      this.l1Cache.set(key, value);
      return this.decompressIfNeeded(value);
    }
    
    // L3ç¼“å­˜æŸ¥æ‰¾
    value = await this.l3Cache.get(key);
    if (value) {
      // æå‡åˆ°L2
      this.l2Cache.set(key, value);
      return this.decompressIfNeeded(value);
    }
    
    return null;
  }
  
  async set(key, value) {
    const size = this.calculateSize(value);
    
    // å¤§å¯¹è±¡å‹ç¼©
    if (size > this.compressionThreshold) {
      value = await this.compressor.compress(value);
    }
    
    // å†™å…¥æ‰€æœ‰å±‚çº§
    this.l1Cache.set(key, value);
    this.l2Cache.set(key, value);
    await this.l3Cache.set(key, value);
  }
  
  // æ™ºèƒ½é¢„å–
  async prefetch(keys) {
    const missing = keys.filter(key => !this.l1Cache.has(key));
    
    if (missing.length > 0) {
      const values = await Promise.all(
        missing.map(key => this.get(key))
      );
      
      missing.forEach((key, index) => {
        if (values[index]) {
          this.l1Cache.set(key, values[index]);
        }
      });
    }
  }
  
  // å†…å­˜å‹åŠ›å¤„ç†
  handleMemoryPressure() {
    // æ¸…ç†L1ç¼“å­˜ä¸­çš„å¤§å¯¹è±¡
    const largeItems = [];
    this.l1Cache.forEach((value, key) => {
      if (this.calculateSize(value) > this.compressionThreshold) {
        largeItems.push(key);
      }
    });
    
    largeItems.forEach(key => this.l1Cache.delete(key));
    
    // å‹ç¼©L2ç¼“å­˜
    const l2Items = [];
    this.l2Cache.forEach((value, key) => {
      l2Items.push({ key, value, size: this.calculateSize(value) });
    });
    
    l2Items.sort((a, b) => b.size - a.size);
    l2Items.slice(0, Math.floor(l2Items.length * 0.3)).forEach(item => {
      this.l2Cache.set(item.key, this.compressor.compress(item.value));
    });
  }
}
```

### 2. æŸ¥è¯¢ä¼˜åŒ–

#### æ™ºèƒ½ç´¢å¼•ç³»ç»Ÿ

```yaml
# .claude/memory/indexing-strategy.yml
indexing_strategy:
  
  index_types:
    
    - type: "semantic_index"
      description: "åŸºäºè¯­ä¹‰ç›¸ä¼¼æ€§çš„ç´¢å¼•"
      fields: ["content_embedding", "concept_embedding"]
      algorithm: "faiss_hnsw"
      parameters:
        dimension: 768
        M: 16
        ef_construction: 200
      
    - type: "full_text_index"
      description: "å…¨æ–‡æœç´¢ç´¢å¼•"
      fields: ["title", "content", "code_snippets"]
      algorithm: "elasticsearch"
      parameters:
        analyzer: "standard"
        tokenizer: "keyword"
        filters: ["lowercase", "stop", "stemmer"]
    
    - type: "temporal_index"
      description: "æ—¶é—´åºåˆ—ç´¢å¼•"
      fields: ["created_at", "last_modified", "last_accessed"]
      algorithm: "btree"
      partitioning: "monthly"
      
    - type: "graph_index"
      description: "çŸ¥è¯†å›¾è°±ç´¢å¼•"
      fields: ["entity_id", "relationship_type", "target_id"]
      algorithm: "adjacency_list"
      optimizations: ["bloom_filter", "compressed_edges"]
      
    - type: "composite_index"
      description: "å¤åˆæŸ¥è¯¢ç´¢å¼•"
      fields: ["project_id", "entity_type", "priority"]
      algorithm: "hash_btree"
      covering: true

  query_optimization:
    
    - strategy: "query_planning"
      description: "æ™ºèƒ½æŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ"
      techniques:
        - "cost_based_optimization"
        - "index_intersection"
        - "predicate_pushdown"
        - "join_reordering"
      
    - strategy: "result_caching"
      description: "æŸ¥è¯¢ç»“æœç¼“å­˜"
      policies:
        - cache_key: "query_hash + user_context"
        - ttl: "based_on_data_volatility"
        - invalidation: "dependency_based"
        - compression: "for_large_results"
      
    - strategy: "progressive_loading"
      description: "æ¸è¿›å¼ç»“æœåŠ è½½"
      implementation:
        - initial_batch: 20
        - batch_increment: 10
        - max_total: 200
        - load_trigger: "scroll_threshold"
        
    - strategy: "parallel_execution"
      description: "å¹¶è¡ŒæŸ¥è¯¢æ‰§è¡Œ"
      conditions:
        - independent_subqueries: true
        - result_size_threshold: 1000
        - cpu_utilization: "< 70%"
      
  adaptive_indexing:
    
    - mechanism: "usage_pattern_analysis"
      description: "åŸºäºä½¿ç”¨æ¨¡å¼è°ƒæ•´ç´¢å¼•"
      metrics:
        - query_frequency: "per_index_field"
        - response_time: "percentile_95"
        - cache_hit_ratio: "per_query_type"
      
    - mechanism: "index_maintenance"
      description: "è‡ªåŠ¨ç´¢å¼•ç»´æŠ¤"
      operations:
        - rebuild_threshold: "fragmentation > 30%"
        - update_frequency: "based_on_data_change_rate"
        - cleanup_schedule: "weekly_unused_indexes"
        
    - mechanism: "dynamic_partitioning"
      description: "åŠ¨æ€æ•°æ®åˆ†åŒº"
      strategies:
        - time_based: "monthly_partitions"
        - size_based: "max_partition_size_100mb"
        - access_based: "hot_warm_cold_tiers"
```

## æ€»ç»“ï¼šæ™ºèƒ½è®°å¿†ç³»ç»Ÿçš„æœªæ¥

é€šè¿‡Claude Codeçš„å†…å­˜ç®¡ç†ä¸ä¸Šä¸‹æ–‡ä¼˜åŒ–ç³»ç»Ÿï¼Œä½ å·²ç»æŒæ¡äº†ï¼š

### ğŸ¯ æ ¸å¿ƒèƒ½åŠ›æå‡

1. **æ™ºèƒ½è®°å¿†ç®¡ç†**ï¼šå¤šå±‚æ¬¡è®°å¿†æ¶æ„ï¼Œä»å·¥ä½œè®°å¿†åˆ°é•¿æœŸè®°å¿†çš„å®Œæ•´ä½“ç³»
2. **ä¸Šä¸‹æ–‡ä¼˜åŒ–**ï¼šåŠ¨æ€å‹ç¼©å’Œé‡æ„ï¼Œç¡®ä¿å…³é”®ä¿¡æ¯çš„ä¿ç•™å’Œé«˜æ•ˆåˆ©ç”¨
3. **çŸ¥è¯†å›¾è°±æ„å»º**ï¼šæ¦‚å¿µå…³ç³»ç½‘ç»œï¼Œæ”¯æŒæ™ºèƒ½çŸ¥è¯†æ£€ç´¢å’Œæ¨ç†
4. **ä¸ªæ€§åŒ–é€‚åº”**ï¼šåŸºäºç”¨æˆ·è¡Œä¸ºçš„è‡ªé€‚åº”å­¦ä¹ å’Œå“åº”å®šåˆ¶
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šå±‚ç¼“å­˜å’Œæ™ºèƒ½ç´¢å¼•ï¼Œä¿è¯ç³»ç»Ÿé«˜æ•ˆè¿è¡Œ

### âš¡ è®°å¿†æ•ˆç‡å¯¹æ¯”

| è®°å¿†åœºæ™¯ | ä¼ ç»ŸAI | æ™ºèƒ½è®°å¿†ç³»ç»Ÿ | æ•ˆæœæå‡ |
|----------|--------|--------------|----------|
| ä¸Šä¸‹æ–‡ä¿æŒ | ä¼šè¯ç»“æŸä¸¢å¤± | æ°¸ä¹…ä¿å­˜ | æ— é™å»¶ç»­ |
| çŸ¥è¯†æ£€ç´¢ | é‡æ–°è§£é‡Š | æ™ºèƒ½æ¨è | 10-50å€æå‡ |
| ä¸ªæ€§åŒ–é€‚åº” | æ— é€‚åº” | åŠ¨æ€å­¦ä¹  | 100%ä¸ªæ€§åŒ– |
| é¡¹ç›®è¿ç»­æ€§ | æ¯æ¬¡é‡æ–°å¼€å§‹ | æ— ç¼å»¶ç»­ | å®Œæ•´è¿è´¯ |
| å­¦ä¹ ç§¯ç´¯ | æ— ç§¯ç´¯ | æŒç»­è¿›åŒ– | æŒ‡æ•°çº§æˆé•¿ |

### ğŸ› ï¸ æ™ºèƒ½è®°å¿†å·¥å…·ç®±

- **å¤šå±‚è®°å¿†æ¶æ„**ï¼šå·¥ä½œè®°å¿†ã€çŸ­æœŸè®°å¿†ã€é•¿æœŸè®°å¿†ã€é¡¹ç›®è®°å¿†
- **ä¸Šä¸‹æ–‡ç®¡ç†**ï¼šæ™ºèƒ½å‹ç¼©ã€åŠ¨æ€é‡æ„ã€ä¼˜å…ˆçº§ç®¡ç†
- **çŸ¥è¯†å›¾è°±**ï¼šæ¦‚å¿µç½‘ç»œã€å…³ç³»æ¨ç†ã€æ™ºèƒ½æŸ¥è¯¢
- **ä¸ªæ€§åŒ–å¼•æ“**ï¼šç”¨æˆ·å»ºæ¨¡ã€è‡ªé€‚åº”å“åº”ã€åå¥½å­¦ä¹ 
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šå±‚ç¼“å­˜ã€æ™ºèƒ½ç´¢å¼•ã€æŸ¥è¯¢ä¼˜åŒ–

### ğŸš€ ç¼–ç¨‹ä½“éªŒé©å‘½

1. **æŒç»­æ€§å¯¹è¯**ï¼šè·¨ä¼šè¯çš„æ— ç¼ä¸Šä¸‹æ–‡å»¶ç»­
2. **æ™ºèƒ½è®°å¿†**ï¼šè‡ªåŠ¨è®°ä½é¡¹ç›®ç»†èŠ‚å’Œç”¨æˆ·åå¥½
3. **ä¸ªæ€§åŒ–ä½“éªŒ**ï¼šæ ¹æ®ä¸ªäººä¹ æƒ¯å®šåˆ¶AIè¡Œä¸º
4. **çŸ¥è¯†ç§¯ç´¯**ï¼šé¡¹ç›®çŸ¥è¯†çš„æŒç»­ç§¯ç´¯å’Œå¤ç”¨
5. **é«˜æ•ˆäº¤äº’**ï¼šæ™ºèƒ½æ¨èå’Œä¸Šä¸‹æ–‡æ„ŸçŸ¥å“åº”

é€šè¿‡æ™ºèƒ½è®°å¿†ç³»ç»Ÿï¼Œæˆ‘ä»¬å®ç°äº†ä»**çŸ­æœŸå¯¹è¯åˆ°é•¿æœŸåä½œ**çš„æ ¹æœ¬è½¬å˜ã€‚è¿™ä¸ä»…è®©AIåŠ©æ‰‹å…·å¤‡äº†çœŸæ­£çš„"è®°å¿†"èƒ½åŠ›ï¼Œæ›´é‡è¦çš„æ˜¯å»ºç«‹äº†**æŒç»­å­¦ä¹ ã€ä¸ªæ€§åŒ–é€‚åº”ã€çŸ¥è¯†ç§¯ç´¯**çš„æ™ºèƒ½ç¼–ç¨‹ä¼™ä¼´å…³ç³»ã€‚

åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¢ç´¢é’©å­ç³»ç»Ÿä¸äº‹ä»¶å¤„ç†ï¼Œå­¦ä¹ å¦‚ä½•è®©Claude Codeå“åº”å„ç§å¼€å‘äº‹ä»¶å¹¶è‡ªåŠ¨æ‰§è¡Œç›¸åº”æ“ä½œã€‚

## ç›¸å…³æ–‡ç« æ¨è

- [å­ä»£ç†Sub-Agentsç³»ç»Ÿæ·±å…¥](18-å­ä»£ç†Sub-Agentsç³»ç»Ÿæ·±å…¥.md)
- [é’©å­Hooksç³»ç»Ÿä¸äº‹ä»¶å¤„ç†](20-é’©å­Hooksç³»ç»Ÿä¸äº‹ä»¶å¤„ç†.md)
- [é«˜çº§é…ç½®ä¸æ€§èƒ½è°ƒä¼˜](21-é«˜çº§é…ç½®ä¸æ€§èƒ½è°ƒä¼˜.md)
- [å›¢é˜Ÿåä½œï¼šå¤šäººå¼€å‘ç¯å¢ƒé…ç½®](23-å›¢é˜Ÿåä½œå¤šäººå¼€å‘ç¯å¢ƒé…ç½®.md)

---

*æœ¬æ–‡æ˜¯ã€ŠClaude Code å®Œæ•´æ•™ç¨‹ç³»åˆ—ã€‹çš„ç¬¬åä¹éƒ¨åˆ†ã€‚æŒæ¡äº†å†…å­˜ç®¡ç†æŠ€èƒ½ï¼Œè®©æˆ‘ä»¬ç»§ç»­æ¢ç´¢é’©å­ç³»ç»Ÿçš„äº‹ä»¶é©±åŠ¨ç¼–ç¨‹ï¼*