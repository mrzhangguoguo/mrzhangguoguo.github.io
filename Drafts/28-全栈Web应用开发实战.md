---
layout: post
title: "å…¨æ ˆWebåº”ç”¨å¼€å‘å®æˆ˜ï¼šClaude Codeé©±åŠ¨çš„ç°ä»£Webå¼€å‘"
date: 2025-08-17 12:00:00 +0800
tags: [Claude Code, å…¨æ ˆå¼€å‘, Webåº”ç”¨, ç°ä»£å‰ç«¯, åç«¯å¼€å‘, å®æˆ˜é¡¹ç›®]
excerpt: "æ·±å…¥æ¢ç´¢ä½¿ç”¨Claude Codeè¿›è¡Œå…¨æ ˆWebåº”ç”¨å¼€å‘çš„å®Œæ•´å®è·µï¼Œä»å‰ç«¯Reactåˆ°åç«¯Node.jsï¼Œä»æ•°æ®åº“è®¾è®¡åˆ°APIå¼€å‘ï¼Œæ„å»ºç°ä»£åŒ–ã€é«˜æ€§èƒ½çš„Webåº”ç”¨ç³»ç»Ÿã€‚"
---

## å¼•è¨€ï¼šå…¨æ ˆå¼€å‘çš„AIæ—¶ä»£

> "The best way to predict the future is to invent it." â€”â€” Alan Kay

åœ¨ç°ä»£Webå¼€å‘ä¸­ï¼Œ**å…¨æ ˆå¼€å‘å·²æˆä¸ºæ„å»ºå®Œæ•´æ•°å­—äº§å“çš„æ ¸å¿ƒæŠ€èƒ½**ã€‚è€ŒClaude Codeçš„å‡ºç°ï¼Œä¸ºå…¨æ ˆå¼€å‘å¸¦æ¥äº†é©å‘½æ€§çš„å˜åŒ–ï¼šAIä¸å†åªæ˜¯è¾…åŠ©å·¥å…·ï¼Œè€Œæ˜¯æˆä¸ºäº†æ™ºèƒ½çš„å¼€å‘ä¼™ä¼´ï¼Œèƒ½å¤Ÿç†è§£ä¸šåŠ¡éœ€æ±‚ã€ç”Ÿæˆé«˜è´¨é‡ä»£ç ã€ä¼˜åŒ–æ¶æ„è®¾è®¡ã€‚

ä¼ ç»Ÿçš„å…¨æ ˆå¼€å‘é¢ä¸´è¯¸å¤šæŒ‘æˆ˜ï¼šå‰åç«¯æŠ€æœ¯æ ˆçš„å¤æ‚æ€§ã€APIè®¾è®¡çš„ä¸€è‡´æ€§ã€æ•°æ®åº“ä¼˜åŒ–ã€éƒ¨ç½²é…ç½®ã€æ€§èƒ½è°ƒä¼˜ç­‰ã€‚Claude Codeé€šè¿‡AIé©±åŠ¨çš„å¼€å‘æ¨¡å¼ï¼Œä¸ä»…èƒ½å¿«é€Ÿç”Ÿæˆå„å±‚ä»£ç ï¼Œæ›´èƒ½ç¡®ä¿æ¶æ„çš„åˆç†æ€§å’Œä»£ç çš„è´¨é‡ã€‚

è¿™ç¯‡æ–‡ç« å°†å¸¦ä½ å®Œæ•´å®è·µä¸€ä¸ªç°ä»£å…¨æ ˆWebåº”ç”¨çš„å¼€å‘è¿‡ç¨‹ï¼Œä»éœ€æ±‚åˆ†æåˆ°æœ€ç»ˆéƒ¨ç½²ï¼Œä½“éªŒAIå¢å¼ºçš„å…¨æ ˆå¼€å‘å¨åŠ›ã€‚

## é¡¹ç›®è§„åˆ’å’Œæ¶æ„è®¾è®¡

### å®æˆ˜é¡¹ç›®ï¼šæ™ºèƒ½ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ

```
é¡¹ç›®æ¦‚è¿° - TaskFlow AI
ğŸ¯ é¡¹ç›®ç›®æ ‡: æ„å»ºä¸€ä¸ªAIå¢å¼ºçš„ä»»åŠ¡ç®¡ç†å¹³å°
ğŸ“‹ æ ¸å¿ƒåŠŸèƒ½:
  - ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†
  - æ™ºèƒ½ä»»åŠ¡åˆ›å»ºå’Œåˆ†ç±»  
  - AIé©±åŠ¨çš„ä»»åŠ¡ä¼˜å…ˆçº§æ¨è
  - å›¢é˜Ÿåä½œå’Œå®æ—¶åŒæ­¥
  - æ•°æ®å¯è§†åŒ–å’ŒæŠ¥å‘Š
  - ç§»åŠ¨ç«¯å“åº”å¼è®¾è®¡

ğŸ—ï¸ æŠ€æœ¯æ ˆé€‰æ‹©:
å‰ç«¯: React 18 + TypeScript + Tailwind CSS + Vite
åç«¯: Node.js + Express + TypeScript + Prisma
æ•°æ®åº“: PostgreSQL + Redis
AIæœåŠ¡: Claude APIé›†æˆ
éƒ¨ç½²: Docker + Nginx + PM2

ğŸ¨ è®¾è®¡ç†å¿µ:
  - ç°ä»£åŒ–UI/UXè®¾è®¡
  - ç»„ä»¶åŒ–å’Œæ¨¡å—åŒ–æ¶æ„
  - ç±»å‹å®‰å…¨çš„å…¨æ ˆå¼€å‘
  - é«˜æ€§èƒ½å’Œå¯æ‰©å±•æ€§
  - æŒç»­é›†æˆå’Œéƒ¨ç½²
```

### ç³»ç»Ÿæ¶æ„è®¾è®¡

```mermaid
graph TB
    A[ç”¨æˆ·ç•Œé¢ - React Frontend] --> B[APIç½‘å…³ - Express.js]
    B --> C[ä¸šåŠ¡é€»è¾‘å±‚ - Controllers]
    C --> D[æœåŠ¡å±‚ - Services]
    D --> E[æ•°æ®è®¿é—®å±‚ - Prisma ORM]
    E --> F[æ•°æ®åº“ - PostgreSQL]
    
    D --> G[ç¼“å­˜å±‚ - Redis]
    D --> H[AIæœåŠ¡ - Claude API]
    D --> I[æ–‡ä»¶å­˜å‚¨ - AWS S3]
    
    J[WebSocket Server] --> A
    K[ä»»åŠ¡è°ƒåº¦å™¨ - Cron Jobs] --> D
    
    subgraph "å¤–éƒ¨æœåŠ¡"
        L[Claude AI API]
        M[é‚®ä»¶æœåŠ¡ - SendGrid]
        N[æ¨é€æœåŠ¡ - FCM]
    end
    
    H --> L
    D --> M
    D --> N
    
    subgraph "ç›‘æ§å’Œæ—¥å¿—"
        O[Prometheus + Grafana]
        P[Winston Logger]
        Q[Sentryé”™è¯¯ç›‘æ§]
    end
    
    B --> O
    C --> P
    A --> Q
```

## å‰ç«¯å¼€å‘å®æˆ˜

### 1. Reacté¡¹ç›®åˆå§‹åŒ–å’Œé…ç½®

#### ä½¿ç”¨Claude Codeåˆ›å»ºé¡¹ç›®ç»“æ„

```bash
# ä½¿ç”¨Claude Codeåˆ›å»ºç°ä»£Reacté¡¹ç›®
claude create react-app taskflow-frontend --template typescript

# è¿›å…¥é¡¹ç›®ç›®å½•
cd taskflow-frontend

# å®‰è£…æ ¸å¿ƒä¾èµ–
npm install @tanstack/react-query axios react-router-dom
npm install @headlessui/react @heroicons/react 
npm install react-hook-form @hookform/resolvers zod
npm install tailwindcss @tailwindcss/forms @tailwindcss/typography

# å®‰è£…å¼€å‘ä¾èµ–
npm install -D @types/react @types/react-dom
npm install -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
npm install -D prettier eslint-plugin-prettier
npm install -D @testing-library/react @testing-library/jest-dom vitest
```

#### ç°ä»£åŒ–é¡¹ç›®ç»“æ„

```
src/
â”œâ”€â”€ components/           # å¯å¤ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ ui/              # åŸºç¡€UIç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”œâ”€â”€ Input.tsx
â”‚   â”‚   â”œâ”€â”€ Modal.tsx
â”‚   â”‚   â””â”€â”€ Loading.tsx
â”‚   â”œâ”€â”€ forms/           # è¡¨å•ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ TaskForm.tsx
â”‚   â”‚   â””â”€â”€ UserForm.tsx
â”‚   â””â”€â”€ layout/          # å¸ƒå±€ç»„ä»¶
â”‚       â”œâ”€â”€ Header.tsx
â”‚       â”œâ”€â”€ Sidebar.tsx
â”‚       â””â”€â”€ Layout.tsx
â”œâ”€â”€ pages/               # é¡µé¢ç»„ä»¶
â”‚   â”œâ”€â”€ auth/           # è®¤è¯ç›¸å…³é¡µé¢
â”‚   â”œâ”€â”€ dashboard/      # ä»ªè¡¨æ¿
â”‚   â”œâ”€â”€ tasks/          # ä»»åŠ¡ç®¡ç†
â”‚   â””â”€â”€ profile/        # ç”¨æˆ·èµ„æ–™
â”œâ”€â”€ hooks/              # è‡ªå®šä¹‰Hooks
â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”œâ”€â”€ useTasks.ts
â”‚   â””â”€â”€ useWebSocket.ts
â”œâ”€â”€ services/           # APIæœåŠ¡
â”‚   â”œâ”€â”€ api.ts          # APIå®¢æˆ·ç«¯é…ç½®
â”‚   â”œâ”€â”€ authService.ts  # è®¤è¯æœåŠ¡
â”‚   â””â”€â”€ taskService.ts  # ä»»åŠ¡æœåŠ¡
â”œâ”€â”€ store/              # çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ authStore.ts    # è®¤è¯çŠ¶æ€
â”‚   â”œâ”€â”€ taskStore.ts    # ä»»åŠ¡çŠ¶æ€
â”‚   â””â”€â”€ uiStore.ts      # UIçŠ¶æ€
â”œâ”€â”€ types/              # TypeScriptç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ auth.ts
â”‚   â”œâ”€â”€ task.ts
â”‚   â””â”€â”€ api.ts
â”œâ”€â”€ utils/              # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ helpers.ts
â”‚   â”œâ”€â”€ validators.ts
â”‚   â””â”€â”€ constants.ts
â””â”€â”€ styles/             # æ ·å¼æ–‡ä»¶
    â”œâ”€â”€ globals.css
    â””â”€â”€ components.css
```

### 2. æ ¸å¿ƒç»„ä»¶å¼€å‘

#### æ™ºèƒ½ä»»åŠ¡è¡¨å•ç»„ä»¶

```typescript
// src/components/forms/TaskForm.tsx
import React, { useState, useEffect } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '../ui/Button';
import { Input } from '../ui/Input';
import { Textarea } from '../ui/Textarea';
import { Select } from '../ui/Select';
import { useClaudeAI } from '../../hooks/useClaudeAI';
import { useTasks } from '../../hooks/useTasks';

// ä»»åŠ¡è¡¨å•éªŒè¯Schema
const taskSchema = z.object({
  title: z.string().min(1, 'ä»»åŠ¡æ ‡é¢˜ä¸èƒ½ä¸ºç©º').max(100, 'æ ‡é¢˜è¿‡é•¿'),
  description: z.string().optional(),
  priority: z.enum(['low', 'medium', 'high', 'urgent']),
  category: z.string().min(1, 'è¯·é€‰æ‹©ä»»åŠ¡åˆ†ç±»'),
  dueDate: z.string().optional(),
  assigneeId: z.string().optional(),
  tags: z.array(z.string()).default([])
});

type TaskFormData = z.infer<typeof taskSchema>;

interface TaskFormProps {
  initialData?: Partial<TaskFormData>;
  onSubmit: (data: TaskFormData) => void;
  onCancel: () => void;
  isLoading?: boolean;
}

export const TaskForm: React.FC<TaskFormProps> = ({
  initialData,
  onSubmit,
  onCancel,
  isLoading = false
}) => {
  const [aiSuggestions, setAiSuggestions] = useState<{
    priority?: string;
    category?: string;
    tags?: string[];
    estimatedTime?: string;
  }>({});
  
  const { generateTaskSuggestions } = useClaudeAI();
  const { categories, users } = useTasks();
  
  const {
    control,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isValid }
  } = useForm<TaskFormData>({
    resolver: zodResolver(taskSchema),
    defaultValues: {
      title: initialData?.title || '',
      description: initialData?.description || '',
      priority: initialData?.priority || 'medium',
      category: initialData?.category || '',
      dueDate: initialData?.dueDate || '',
      assigneeId: initialData?.assigneeId || '',
      tags: initialData?.tags || []
    }
  });
  
  const watchedTitle = watch('title');
  const watchedDescription = watch('description');
  
  // AIå¢å¼ºï¼šåŸºäºæ ‡é¢˜å’Œæè¿°ç”Ÿæˆæ™ºèƒ½å»ºè®®
  useEffect(() => {
    const generateAISuggestions = async () => {
      if (watchedTitle.length > 5) {
        try {
          const suggestions = await generateTaskSuggestions({
            title: watchedTitle,
            description: watchedDescription
          });
          
          setAiSuggestions(suggestions);
          
          // è‡ªåŠ¨åº”ç”¨AIå»ºè®®ï¼ˆç”¨æˆ·å¯ä»¥ä¿®æ”¹ï¼‰
          if (suggestions.priority && !initialData?.priority) {
            setValue('priority', suggestions.priority as any);
          }
          
          if (suggestions.category && !initialData?.category) {
            setValue('category', suggestions.category);
          }
          
          if (suggestions.tags && suggestions.tags.length > 0) {
            setValue('tags', suggestions.tags);
          }
          
        } catch (error) {
          console.error('ç”ŸæˆAIå»ºè®®å¤±è´¥:', error);
        }
      }
    };
    
    const debounceTimer = setTimeout(generateAISuggestions, 1000);
    return () => clearTimeout(debounceTimer);
  }, [watchedTitle, watchedDescription, generateTaskSuggestions, setValue, initialData]);
  
  const handleFormSubmit = (data: TaskFormData) => {
    onSubmit(data);
  };
  
  const applyAISuggestion = (field: keyof TaskFormData, value: any) => {
    setValue(field, value);
  };
  
  return (
    <div className="max-w-2xl mx-auto p-6 bg-white rounded-lg shadow-lg">
      <h2 className="text-2xl font-bold text-gray-900 mb-6">
        {initialData ? 'ç¼–è¾‘ä»»åŠ¡' : 'åˆ›å»ºæ–°ä»»åŠ¡'}
      </h2>
      
      <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-6">
        {/* ä»»åŠ¡æ ‡é¢˜ */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            ä»»åŠ¡æ ‡é¢˜ *
          </label>
          <Controller
            name="title"
            control={control}
            render={({ field }) => (
              <Input
                {...field}
                placeholder="è¾“å…¥ä»»åŠ¡æ ‡é¢˜..."
                error={errors.title?.message}
                className="w-full"
              />
            )}
          />
        </div>
        
        {/* ä»»åŠ¡æè¿° */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            ä»»åŠ¡æè¿°
          </label>
          <Controller
            name="description"
            control={control}
            render={({ field }) => (
              <Textarea
                {...field}
                placeholder="è¯¦ç»†æè¿°ä»»åŠ¡å†…å®¹..."
                rows={4}
                className="w-full"
              />
            )}
          />
        </div>
        
        {/* AIå»ºè®®å¡ç‰‡ */}
        {Object.keys(aiSuggestions).length > 0 && (
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <h3 className="text-sm font-medium text-blue-900 mb-3 flex items-center">
              <span className="mr-2">ğŸ¤–</span>
              AIæ™ºèƒ½å»ºè®®
            </h3>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {aiSuggestions.priority && (
                <div className="flex items-center justify-between">
                  <span className="text-sm text-gray-700">
                    å»ºè®®ä¼˜å…ˆçº§: <strong>{aiSuggestions.priority}</strong>
                  </span>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => applyAISuggestion('priority', aiSuggestions.priority)}
                  >
                    åº”ç”¨
                  </Button>
                </div>
              )}
              
              {aiSuggestions.category && (
                <div className="flex items-center justify-between">
                  <span className="text-sm text-gray-700">
                    å»ºè®®åˆ†ç±»: <strong>{aiSuggestions.category}</strong>
                  </span>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => applyAISuggestion('category', aiSuggestions.category)}
                  >
                    åº”ç”¨
                  </Button>
                </div>
              )}
              
              {aiSuggestions.tags && aiSuggestions.tags.length > 0 && (
                <div className="flex items-center justify-between">
                  <span className="text-sm text-gray-700">
                    å»ºè®®æ ‡ç­¾: <strong>{aiSuggestions.tags.join(', ')}</strong>
                  </span>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => applyAISuggestion('tags', aiSuggestions.tags)}
                  >
                    åº”ç”¨
                  </Button>
                </div>
              )}
              
              {aiSuggestions.estimatedTime && (
                <div className="col-span-2">
                  <span className="text-sm text-gray-700">
                    é¢„ä¼°å®Œæˆæ—¶é—´: <strong>{aiSuggestions.estimatedTime}</strong>
                  </span>
                </div>
              )}
            </div>
          </div>
        )}
        
        {/* è¡¨å•å­—æ®µç½‘æ ¼ */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* ä¼˜å…ˆçº§ */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              ä¼˜å…ˆçº§ *
            </label>
            <Controller
              name="priority"
              control={control}
              render={({ field }) => (
                <Select
                  {...field}
                  options={[
                    { value: 'low', label: 'ä½ä¼˜å…ˆçº§' },
                    { value: 'medium', label: 'ä¸­ä¼˜å…ˆçº§' },
                    { value: 'high', label: 'é«˜ä¼˜å…ˆçº§' },
                    { value: 'urgent', label: 'ç´§æ€¥' }
                  ]}
                  error={errors.priority?.message}
                />
              )}
            />
          </div>
          
          {/* åˆ†ç±» */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              ä»»åŠ¡åˆ†ç±» *
            </label>
            <Controller
              name="category"
              control={control}
              render={({ field }) => (
                <Select
                  {...field}
                  options={categories.map(cat => ({
                    value: cat.id,
                    label: cat.name
                  }))}
                  error={errors.category?.message}
                />
              )}
            />
          </div>
          
          {/* æˆªæ­¢æ—¥æœŸ */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              æˆªæ­¢æ—¥æœŸ
            </label>
            <Controller
              name="dueDate"
              control={control}
              render={({ field }) => (
                <Input
                  {...field}
                  type="datetime-local"
                  className="w-full"
                />
              )}
            />
          </div>
          
          {/* æŒ‡æ´¾äººå‘˜ */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              æŒ‡æ´¾ç»™
            </label>
            <Controller
              name="assigneeId"
              control={control}
              render={({ field }) => (
                <Select
                  {...field}
                  options={[
                    { value: '', label: 'æœªæŒ‡æ´¾' },
                    ...users.map(user => ({
                      value: user.id,
                      label: user.name
                    }))
                  ]}
                />
              )}
            />
          </div>
        </div>
        
        {/* æ ‡ç­¾ */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            æ ‡ç­¾
          </label>
          <Controller
            name="tags"
            control={control}
            render={({ field }) => (
              <TagInput
                value={field.value}
                onChange={field.onChange}
                placeholder="æ·»åŠ æ ‡ç­¾..."
              />
            )}
          />
        </div>
        
        {/* æ“ä½œæŒ‰é’® */}
        <div className="flex items-center justify-end space-x-4 pt-6 border-t">
          <Button
            type="button"
            variant="outline"
            onClick={onCancel}
            disabled={isLoading}
          >
            å–æ¶ˆ
          </Button>
          <Button
            type="submit"
            disabled={!isValid || isLoading}
            loading={isLoading}
          >
            {initialData ? 'æ›´æ–°ä»»åŠ¡' : 'åˆ›å»ºä»»åŠ¡'}
          </Button>
        </div>
      </form>
    </div>
  );
};

// æ ‡ç­¾è¾“å…¥ç»„ä»¶
const TagInput: React.FC<{
  value: string[];
  onChange: (tags: string[]) => void;
  placeholder?: string;
}> = ({ value, onChange, placeholder }) => {
  const [inputValue, setInputValue] = useState('');
  
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ',') {
      e.preventDefault();
      const newTag = inputValue.trim();
      if (newTag && !value.includes(newTag)) {
        onChange([...value, newTag]);
        setInputValue('');
      }
    }
  };
  
  const removeTag = (tagToRemove: string) => {
    onChange(value.filter(tag => tag !== tagToRemove));
  };
  
  return (
    <div className="border border-gray-300 rounded-md p-2 focus-within:ring-2 focus-within:ring-blue-500">
      <div className="flex flex-wrap gap-2 mb-2">
        {value.map((tag, index) => (
          <span
            key={index}
            className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800"
          >
            {tag}
            <button
              type="button"
              onClick={() => removeTag(tag)}
              className="ml-1 text-blue-600 hover:text-blue-800"
            >
              Ã—
            </button>
          </span>
        ))}
      </div>
      <input
        type="text"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        className="w-full border-none outline-none text-sm"
      />
    </div>
  );
};
```

#### æ™ºèƒ½ä»ªè¡¨æ¿ç»„ä»¶

```typescript
// src/components/dashboard/Dashboard.tsx
import React, { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { 
  CalendarIcon, 
  ClockIcon, 
  ChartBarIcon,
  UserIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon
} from '@heroicons/react/24/outline';
import { useTasks } from '../../hooks/useTasks';
import { useAuth } from '../../hooks/useAuth';
import { useClaudeAI } from '../../hooks/useClaudeAI';
import { StatCard } from '../ui/StatCard';
import { TaskList } from './TaskList';
import { ProductivityChart } from './ProductivityChart';
import { AIInsights } from './AIInsights';

export const Dashboard: React.FC = () => {
  const { user } = useAuth();
  const { 
    tasks, 
    getTaskStats, 
    getUpcomingTasks,
    getOverdueTasks,
    getCompletedTasksThisWeek 
  } = useTasks();
  const { generateProductivityInsights } = useClaudeAI();
  
  const [aiInsights, setAiInsights] = useState<any>(null);
  
  // è·å–ä»»åŠ¡ç»Ÿè®¡æ•°æ®
  const { data: taskStats } = useQuery({
    queryKey: ['taskStats'],
    queryFn: getTaskStats
  });
  
  // è·å–å³å°†åˆ°æœŸçš„ä»»åŠ¡
  const { data: upcomingTasks } = useQuery({
    queryKey: ['upcomingTasks'],
    queryFn: () => getUpcomingTasks(7) // æœªæ¥7å¤©
  });
  
  // è·å–é€¾æœŸä»»åŠ¡
  const { data: overdueTasks } = useQuery({
    queryKey: ['overdueTasks'],
    queryFn: getOverdueTasks
  });
  
  // è·å–æœ¬å‘¨å®Œæˆçš„ä»»åŠ¡
  const { data: completedTasks } = useQuery({
    queryKey: ['completedTasksThisWeek'],
    queryFn: getCompletedTasksThisWeek
  });
  
  // ç”ŸæˆAIç”Ÿäº§åŠ›æ´å¯Ÿ
  useEffect(() => {
    const generateInsights = async () => {
      if (taskStats && completedTasks) {
        try {
          const insights = await generateProductivityInsights({
            taskStats,
            completedTasks,
            userWorkingHours: user?.preferences?.workingHours || '9-17'
          });
          setAiInsights(insights);
        } catch (error) {
          console.error('ç”ŸæˆAIæ´å¯Ÿå¤±è´¥:', error);
        }
      }
    };
    
    generateInsights();
  }, [taskStats, completedTasks, generateProductivityInsights, user]);
  
  if (!taskStats) {
    return <div className="flex justify-center items-center h-64">
      <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
    </div>;
  }
  
  return (
    <div className="space-y-6">
      {/* æ¬¢è¿æ ‡é¢˜ */}
      <div className="bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg p-6 text-white">
        <h1 className="text-2xl font-bold mb-2">
          æ¬¢è¿å›æ¥, {user?.name}ï¼
        </h1>
        <p className="text-blue-100">
          ä»Šå¤©æ˜¯ {new Date().toLocaleDateString('zh-CN', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            weekday: 'long'
          })}
        </p>
      </div>
      
      {/* ç»Ÿè®¡å¡ç‰‡ */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <StatCard
          title="æ€»ä»»åŠ¡æ•°"
          value={taskStats.total}
          icon={<ChartBarIcon className="h-6 w-6" />}
          color="blue"
          trend={taskStats.totalTrend}
        />
        
        <StatCard
          title="å¾…å®Œæˆ"
          value={taskStats.pending}
          icon={<ClockIcon className="h-6 w-6" />}
          color="yellow"
          trend={taskStats.pendingTrend}
        />
        
        <StatCard
          title="å·²å®Œæˆ"
          value={taskStats.completed}
          icon={<CheckCircleIcon className="h-6 w-6" />}
          color="green"
          trend={taskStats.completedTrend}
        />
        
        <StatCard
          title="é€¾æœŸä»»åŠ¡"
          value={overdueTasks?.length || 0}
          icon={<ExclamationTriangleIcon className="h-6 w-6" />}
          color="red"
          urgent={overdueTasks && overdueTasks.length > 0}
        />
      </div>
      
      {/* AIæ´å¯Ÿ */}
      {aiInsights && (
        <AIInsights insights={aiInsights} />
      )}
      
      {/* ä¸»è¦å†…å®¹åŒºåŸŸ */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* å³å°†åˆ°æœŸçš„ä»»åŠ¡ */}
        <div className="lg:col-span-2">
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-lg font-semibold text-gray-900 mb-4 flex items-center">
              <CalendarIcon className="h-5 w-5 mr-2 text-gray-600" />
              å³å°†åˆ°æœŸçš„ä»»åŠ¡
            </h2>
            <TaskList 
              tasks={upcomingTasks || []}
              showStatus={false}
              showDueDate={true}
              compact={true}
            />
          </div>
        </div>
        
        {/* ç”Ÿäº§åŠ›å›¾è¡¨ */}
        <div>
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-lg font-semibold text-gray-900 mb-4">
              æœ¬å‘¨ç”Ÿäº§åŠ›
            </h2>
            <ProductivityChart data={completedTasks} />
          </div>
        </div>
      </div>
      
      {/* é€¾æœŸä»»åŠ¡æé†’ */}
      {overdueTasks && overdueTasks.length > 0 && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-6">
          <h2 className="text-lg font-semibold text-red-900 mb-4 flex items-center">
            <ExclamationTriangleIcon className="h-5 w-5 mr-2" />
            é€¾æœŸä»»åŠ¡æé†’
          </h2>
          <TaskList 
            tasks={overdueTasks}
            showStatus={true}
            showDueDate={true}
            variant="danger"
          />
        </div>
      )}
      
      {/* æœ€è¿‘æ´»åŠ¨ */}
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-lg font-semibold text-gray-900 mb-4">
          æœ€è¿‘æ´»åŠ¨
        </h2>
        <RecentActivity />
      </div>
    </div>
  );
};

// AIæ´å¯Ÿç»„ä»¶
const AIInsights: React.FC<{ insights: any }> = ({ insights }) => {
  return (
    <div className="bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg p-6 border border-purple-200">
      <h2 className="text-lg font-semibold text-gray-900 mb-4 flex items-center">
        <span className="mr-2">ğŸ¤–</span>
        AIç”Ÿäº§åŠ›æ´å¯Ÿ
      </h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {insights.recommendations?.map((rec: any, index: number) => (
          <div key={index} className="bg-white rounded-lg p-4 shadow-sm">
            <h3 className="font-medium text-gray-900 mb-2">{rec.title}</h3>
            <p className="text-sm text-gray-600 mb-3">{rec.description}</p>
            <div className="flex items-center justify-between">
              <span className="text-xs text-purple-600 font-medium">
                é¢„æœŸæ•ˆæœ: {rec.expectedImpact}
              </span>
              <button className="text-xs bg-purple-100 text-purple-700 px-2 py-1 rounded">
                æŸ¥çœ‹è¯¦æƒ…
              </button>
            </div>
          </div>
        ))}
      </div>
      
      {insights.productivity_score && (
        <div className="mt-4 p-4 bg-white rounded-lg">
          <div className="flex items-center justify-between">
            <span className="text-sm font-medium text-gray-700">
              æœ¬å‘¨ç”Ÿäº§åŠ›è¯„åˆ†
            </span>
            <span className="text-2xl font-bold text-purple-600">
              {insights.productivity_score}/100
            </span>
          </div>
          <div className="mt-2 w-full bg-gray-200 rounded-full h-2">
            <div 
              className="bg-gradient-to-r from-purple-500 to-blue-500 h-2 rounded-full"
              style={{ width: `${insights.productivity_score}%` }}
            ></div>
          </div>
        </div>
      )}
    </div>
  );
};

// æœ€è¿‘æ´»åŠ¨ç»„ä»¶
const RecentActivity: React.FC = () => {
  const { data: activities } = useQuery({
    queryKey: ['recentActivities'],
    queryFn: () => fetch('/api/activities/recent').then(res => res.json())
  });
  
  if (!activities) return <div>åŠ è½½ä¸­...</div>;
  
  return (
    <div className="space-y-4">
      {activities.map((activity: any) => (
        <div key={activity.id} className="flex items-center space-x-4 p-3 bg-gray-50 rounded-lg">
          <div className="flex-shrink-0">
            <UserIcon className="h-8 w-8 text-gray-400" />
          </div>
          <div className="flex-1 min-w-0">
            <p className="text-sm text-gray-900">
              <span className="font-medium">{activity.user.name}</span>
              {' '}
              <span>{activity.action}</span>
              {' '}
              <span className="font-medium">{activity.task.title}</span>
            </p>
            <p className="text-xs text-gray-500">
              {new Date(activity.createdAt).toLocaleString('zh-CN')}
            </p>
          </div>
        </div>
      ))}
    </div>
  );
};
```

### 3. çŠ¶æ€ç®¡ç†å’ŒAPIé›†æˆ

#### React Queryå’ŒçŠ¶æ€ç®¡ç†

```typescript
// src/hooks/useTasks.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'react-hot-toast';
import { taskService } from '../services/taskService';
import { Task, CreateTaskData, UpdateTaskData, TaskFilters } from '../types/task';

export const useTasks = (filters?: TaskFilters) => {
  const queryClient = useQueryClient();
  
  // è·å–ä»»åŠ¡åˆ—è¡¨
  const {
    data: tasks = [],
    isLoading,
    error,
    refetch
  } = useQuery({
    queryKey: ['tasks', filters],
    queryFn: () => taskService.getTasks(filters),
    staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿ
  });
  
  // åˆ›å»ºä»»åŠ¡
  const createTaskMutation = useMutation({
    mutationFn: (data: CreateTaskData) => taskService.createTask(data),
    onSuccess: (newTask) => {
      queryClient.invalidateQueries({ queryKey: ['tasks'] });
      queryClient.invalidateQueries({ queryKey: ['taskStats'] });
      toast.success('ä»»åŠ¡åˆ›å»ºæˆåŠŸï¼');
    },
    onError: (error: any) => {
      toast.error(error.message || 'åˆ›å»ºä»»åŠ¡å¤±è´¥');
    }
  });
  
  // æ›´æ–°ä»»åŠ¡
  const updateTaskMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateTaskData }) => 
      taskService.updateTask(id, data),
    onSuccess: (updatedTask) => {
      queryClient.invalidateQueries({ queryKey: ['tasks'] });
      queryClient.invalidateQueries({ queryKey: ['task', updatedTask.id] });
      toast.success('ä»»åŠ¡æ›´æ–°æˆåŠŸï¼');
    },
    onError: (error: any) => {
      toast.error(error.message || 'æ›´æ–°ä»»åŠ¡å¤±è´¥');
    }
  });
  
  // åˆ é™¤ä»»åŠ¡
  const deleteTaskMutation = useMutation({
    mutationFn: (id: string) => taskService.deleteTask(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tasks'] });
      queryClient.invalidateQueries({ queryKey: ['taskStats'] });
      toast.success('ä»»åŠ¡åˆ é™¤æˆåŠŸï¼');
    },
    onError: (error: any) => {
      toast.error(error.message || 'åˆ é™¤ä»»åŠ¡å¤±è´¥');
    }
  });
  
  // å®Œæˆä»»åŠ¡
  const completeTaskMutation = useMutation({
    mutationFn: (id: string) => taskService.completeTask(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tasks'] });
      queryClient.invalidateQueries({ queryKey: ['taskStats'] });
      toast.success('ä»»åŠ¡å®Œæˆï¼');
    },
    onError: (error: any) => {
      toast.error(error.message || 'å®Œæˆä»»åŠ¡å¤±è´¥');
    }
  });
  
  // æ‰¹é‡æ“ä½œ
  const batchUpdateMutation = useMutation({
    mutationFn: ({ ids, updates }: { ids: string[]; updates: Partial<Task> }) =>
      taskService.batchUpdate(ids, updates),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tasks'] });
      toast.success('æ‰¹é‡æ“ä½œæˆåŠŸï¼');
    },
    onError: (error: any) => {
      toast.error(error.message || 'æ‰¹é‡æ“ä½œå¤±è´¥');
    }
  });
  
  return {
    // æ•°æ®
    tasks,
    isLoading,
    error,
    
    // æ“ä½œ
    createTask: createTaskMutation.mutate,
    updateTask: updateTaskMutation.mutate,
    deleteTask: deleteTaskMutation.mutate,
    completeTask: completeTaskMutation.mutate,
    batchUpdate: batchUpdateMutation.mutate,
    refetch,
    
    // çŠ¶æ€
    isCreating: createTaskMutation.isPending,
    isUpdating: updateTaskMutation.isPending,
    isDeleting: deleteTaskMutation.isPending,
    isCompleting: completeTaskMutation.isPending,
    isBatchUpdating: batchUpdateMutation.isPending,
    
    // è¾…åŠ©æ–¹æ³•
    getTaskById: (id: string) => tasks.find((task: Task) => task.id === id),
    getTasksByStatus: (status: string) => tasks.filter((task: Task) => task.status === status),
    getTasksByPriority: (priority: string) => tasks.filter((task: Task) => task.priority === priority),
  };
};

// Claude AIé›†æˆHook
export const useClaudeAI = () => {
  const generateTaskSuggestions = async (taskData: {
    title: string;
    description?: string;
  }) => {
    try {
      const response = await fetch('/api/ai/task-suggestions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(taskData)
      });
      
      if (!response.ok) {
        throw new Error('ç”Ÿæˆå»ºè®®å¤±è´¥');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Claude AI API é”™è¯¯:', error);
      throw error;
    }
  };
  
  const generateProductivityInsights = async (data: {
    taskStats: any;
    completedTasks: any[];
    userWorkingHours: string;
  }) => {
    try {
      const response = await fetch('/api/ai/productivity-insights', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        throw new Error('ç”Ÿæˆæ´å¯Ÿå¤±è´¥');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Claude AI API é”™è¯¯:', error);
      throw error;
    }
  };
  
  const optimizeTaskSchedule = async (tasks: Task[]) => {
    try {
      const response = await fetch('/api/ai/optimize-schedule', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ tasks })
      });
      
      if (!response.ok) {
        throw new Error('ä¼˜åŒ–æ’ç¨‹å¤±è´¥');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Claude AI API é”™è¯¯:', error);
      throw error;
    }
  };
  
  return {
    generateTaskSuggestions,
    generateProductivityInsights,
    optimizeTaskSchedule
  };
};
```

## åç«¯å¼€å‘å®æˆ˜

### 1. Node.jsé¡¹ç›®ç»“æ„å’Œé…ç½®

#### Express + TypeScript + Prismaæ¶æ„

```typescript
// src/app.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import compression from 'compression';
import { PrismaClient } from '@prisma/client';
import { createServer } from 'http';
import { Server as SocketServer } from 'socket.io';
import { authRouter } from './routes/auth';
import { taskRouter } from './routes/tasks';
import { userRouter } from './routes/users';
import { aiRouter } from './routes/ai';
import { errorHandler } from './middleware/errorHandler';
import { authMiddleware } from './middleware/auth';
import { loggerMiddleware } from './middleware/logger';
import { setupWebSocket } from './services/websocket';
import { setupCronJobs } from './services/scheduler';

// åˆå§‹åŒ–æ•°æ®åº“å®¢æˆ·ç«¯
export const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
});

// åˆ›å»ºExpressåº”ç”¨
const app = express();
const server = createServer(app);
const io = new SocketServer(server, {
  cors: {
    origin: process.env.FRONTEND_URL || "http://localhost:3000",
    methods: ["GET", "POST"]
  }
});

// åŸºç¡€ä¸­é—´ä»¶
app.use(helmet());
app.use(compression());
app.use(cors({
  origin: process.env.FRONTEND_URL || "http://localhost:3000",
  credentials: true
}));

// é€Ÿç‡é™åˆ¶
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  max: 100, // é™åˆ¶æ¯ä¸ªIP 15åˆ†é’Ÿå†…æœ€å¤š100ä¸ªè¯·æ±‚
  message: {
    error: 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•'
  }
});
app.use('/api/', limiter);

// è§£æè¯·æ±‚ä½“
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// æ—¥å¿—ä¸­é—´ä»¶
app.use(loggerMiddleware);

// å¥åº·æ£€æŸ¥
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    version: process.env.APP_VERSION || '1.0.0'
  });
});

// APIè·¯ç”±
app.use('/api/auth', authRouter);
app.use('/api/tasks', authMiddleware, taskRouter);
app.use('/api/users', authMiddleware, userRouter);
app.use('/api/ai', authMiddleware, aiRouter);

// é”™è¯¯å¤„ç†
app.use(errorHandler);

// è®¾ç½®WebSocket
setupWebSocket(io);

// è®¾ç½®å®šæ—¶ä»»åŠ¡
setupCronJobs();

// ä¼˜é›…å…³é—­
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully');
  await prisma.$disconnect();
  server.close(() => {
    console.log('Process terminated');
  });
});

export { app, server, io };
```

#### æ•°æ®åº“æ¨¡å‹è®¾è®¡ (Prisma Schema)

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  avatar    String?
  password  String
  role      Role     @default(USER)
  
  // ç”¨æˆ·åå¥½è®¾ç½®
  preferences Json?
  
  // æ—¶é—´æˆ³
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // å…³ç³»
  tasks         Task[]
  assignedTasks Task[] @relation("TaskAssignee")
  comments      Comment[]
  activities    Activity[]
  
  @@map("users")
}

model Task {
  id          String     @id @default(cuid())
  title       String
  description String?
  status      TaskStatus @default(TODO)
  priority    Priority   @default(MEDIUM)
  
  // åˆ†ç±»å’Œæ ‡ç­¾
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String
  tags       Tag[]
  
  // æ—¶é—´ç®¡ç†
  dueDate      DateTime?
  estimatedTime Int? // é¢„ä¼°æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
  actualTime   Int? // å®é™…ç”¨æ—¶ï¼ˆåˆ†é’Ÿï¼‰
  startedAt    DateTime?
  completedAt  DateTime?
  
  // ç”¨æˆ·å…³ç³»
  creator   User   @relation(fields: [creatorId], references: [id])
  creatorId String
  assignee  User?  @relation("TaskAssignee", fields: [assigneeId], references: [id])
  assigneeId String?
  
  // AIå¢å¼ºå­—æ®µ
  aiSuggestions Json? // AIå»ºè®®çš„å†…å®¹
  complexityScore Float? // å¤æ‚åº¦è¯„åˆ†
  
  // æ—¶é—´æˆ³
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // å…³ç³»
  comments   Comment[]
  activities Activity[]
  subtasks   Task[]    @relation("SubTasks")
  parentTask Task?     @relation("SubTasks", fields: [parentId], references: [id])
  parentId   String?
  
  @@map("tasks")
}

model Category {
  id          String @id @default(cuid())
  name        String @unique
  description String?
  color       String @default("#3B82F6")
  
  // æ—¶é—´æˆ³
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // å…³ç³»
  tasks Task[]
  
  @@map("categories")
}

model Tag {
  id    String @id @default(cuid())
  name  String @unique
  color String @default("#6B7280")
  
  // æ—¶é—´æˆ³
  createdAt DateTime @default(now())
  
  // å…³ç³»
  tasks Task[]
  
  @@map("tags")
}

model Comment {
  id      String @id @default(cuid())
  content String
  
  // å…³ç³»
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId String
  user   User   @relation(fields: [userId], references: [id])
  userId String
  
  // æ—¶é—´æˆ³
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("comments")
}

model Activity {
  id     String       @id @default(cuid())
  type   ActivityType
  action String
  
  // å…ƒæ•°æ®
  metadata Json?
  
  // å…³ç³»
  user   User   @relation(fields: [userId], references: [id])
  userId String
  task   Task?  @relation(fields: [taskId], references: [id])
  taskId String?
  
  // æ—¶é—´æˆ³
  createdAt DateTime @default(now())
  
  @@map("activities")
}

// æšä¸¾ç±»å‹
enum Role {
  USER
  ADMIN
  MANAGER
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  IN_REVIEW
  COMPLETED
  CANCELLED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ActivityType {
  TASK_CREATED
  TASK_UPDATED
  TASK_COMPLETED
  TASK_DELETED
  COMMENT_ADDED
  USER_ASSIGNED
}
```

### 2. æ ¸å¿ƒä¸šåŠ¡é€»è¾‘å®ç°

#### ä»»åŠ¡æœåŠ¡å±‚

```typescript
// src/services/taskService.ts
import { PrismaClient, Task, TaskStatus, Priority } from '@prisma/client';
import { ClaudeAIService } from './claudeAI';
import { NotificationService } from './notification';
import { ActivityService } from './activity';
import { CreateTaskData, UpdateTaskData, TaskFilters } from '../types/task';

export class TaskService {
  constructor(
    private prisma: PrismaClient,
    private claudeAI: ClaudeAIService,
    private notification: NotificationService,
    private activity: ActivityService
  ) {}
  
  async createTask(data: CreateTaskData, creatorId: string): Promise<Task> {
    try {
      // ä½¿ç”¨Claude AIå¢å¼ºä»»åŠ¡åˆ›å»º
      const aiEnhancements = await this.claudeAI.enhanceTaskCreation({
        title: data.title,
        description: data.description,
        category: data.categoryId
      });
      
      // åˆ›å»ºä»»åŠ¡
      const task = await this.prisma.task.create({
        data: {
          ...data,
          creatorId,
          aiSuggestions: aiEnhancements,
          complexityScore: aiEnhancements.complexityScore,
          estimatedTime: aiEnhancements.estimatedTime
        },
        include: {
          creator: true,
          assignee: true,
          category: true,
          tags: true
        }
      });
      
      // è®°å½•æ´»åŠ¨
      await this.activity.recordActivity({
        type: 'TASK_CREATED',
        action: 'åˆ›å»ºäº†ä»»åŠ¡',
        userId: creatorId,
        taskId: task.id,
        metadata: { taskTitle: task.title }
      });
      
      // å‘é€é€šçŸ¥
      if (task.assigneeId && task.assigneeId !== creatorId) {
        await this.notification.sendTaskAssignedNotification(
          task.assigneeId,
          task
        );
      }
      
      return task;
    } catch (error) {
      throw new Error(`åˆ›å»ºä»»åŠ¡å¤±è´¥: ${error.message}`);
    }
  }
  
  async updateTask(
    id: string, 
    data: UpdateTaskData, 
    userId: string
  ): Promise<Task> {
    try {
      // è·å–å½“å‰ä»»åŠ¡
      const currentTask = await this.prisma.task.findUnique({
        where: { id },
        include: { assignee: true }
      });
      
      if (!currentTask) {
        throw new Error('ä»»åŠ¡ä¸å­˜åœ¨');
      }
      
      // æ£€æŸ¥æƒé™
      const canUpdate = await this.checkUpdatePermission(currentTask, userId);
      if (!canUpdate) {
        throw new Error('æ²¡æœ‰æƒé™æ›´æ–°æ­¤ä»»åŠ¡');
      }
      
      // AIæ™ºèƒ½æ›´æ–°å»ºè®®
      let aiSuggestions = currentTask.aiSuggestions;
      if (data.title || data.description) {
        const suggestions = await this.claudeAI.getUpdateSuggestions({
          currentTask,
          updates: data
        });
        aiSuggestions = { ...aiSuggestions, ...suggestions };
      }
      
      // æ›´æ–°ä»»åŠ¡
      const updatedTask = await this.prisma.task.update({
        where: { id },
        data: {
          ...data,
          aiSuggestions,
          updatedAt: new Date()
        },
        include: {
          creator: true,
          assignee: true,
          category: true,
          tags: true
        }
      });
      
      // è®°å½•æ´»åŠ¨å’Œå‘é€é€šçŸ¥
      await this.handleTaskUpdateEffects(currentTask, updatedTask, userId);
      
      return updatedTask;
    } catch (error) {
      throw new Error(`æ›´æ–°ä»»åŠ¡å¤±è´¥: ${error.message}`);
    }
  }
  
  async getTasks(filters: TaskFilters, userId: string): Promise<Task[]> {
    const whereClause: any = {
      OR: [
        { creatorId: userId },
        { assigneeId: userId }
      ]
    };
    
    // åº”ç”¨è¿‡æ»¤å™¨
    if (filters.status) {
      whereClause.status = filters.status;
    }
    
    if (filters.priority) {
      whereClause.priority = filters.priority;
    }
    
    if (filters.categoryId) {
      whereClause.categoryId = filters.categoryId;
    }
    
    if (filters.search) {
      whereClause.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } }
      ];
    }
    
    if (filters.dueDate) {
      whereClause.dueDate = {
        lte: new Date(filters.dueDate)
      };
    }
    
    return await this.prisma.task.findMany({
      where: whereClause,
      include: {
        creator: true,
        assignee: true,
        category: true,
        tags: true,
        _count: {
          select: {
            comments: true,
            subtasks: true
          }
        }
      },
      orderBy: [
        { priority: 'desc' },
        { dueDate: 'asc' },
        { createdAt: 'desc' }
      ]
    });
  }
  
  async completeTask(id: string, userId: string): Promise<Task> {
    try {
      const task = await this.prisma.task.findUnique({
        where: { id },
        include: { assignee: true, creator: true }
      });
      
      if (!task) {
        throw new Error('ä»»åŠ¡ä¸å­˜åœ¨');
      }
      
      // æ£€æŸ¥æƒé™
      const canComplete = task.assigneeId === userId || task.creatorId === userId;
      if (!canComplete) {
        throw new Error('æ²¡æœ‰æƒé™å®Œæˆæ­¤ä»»åŠ¡');
      }
      
      const completedTask = await this.prisma.task.update({
        where: { id },
        data: {
          status: TaskStatus.COMPLETED,
          completedAt: new Date(),
          actualTime: task.startedAt ? 
            Math.round((Date.now() - task.startedAt.getTime()) / 60000) : 
            undefined
        },
        include: {
          creator: true,
          assignee: true,
          category: true,
          tags: true
        }
      });
      
      // è®°å½•æ´»åŠ¨
      await this.activity.recordActivity({
        type: 'TASK_COMPLETED',
        action: 'å®Œæˆäº†ä»»åŠ¡',
        userId,
        taskId: id,
        metadata: { 
          taskTitle: task.title,
          actualTime: completedTask.actualTime
        }
      });
      
      // AIåˆ†æå®Œæˆæ•ˆç‡
      await this.analyzeTaskCompletion(completedTask);
      
      // å‘é€å®Œæˆé€šçŸ¥
      if (task.creatorId !== userId) {
        await this.notification.sendTaskCompletedNotification(
          task.creatorId,
          completedTask
        );
      }
      
      return completedTask;
    } catch (error) {
      throw new Error(`å®Œæˆä»»åŠ¡å¤±è´¥: ${error.message}`);
    }
  }
  
  async getTaskStatistics(userId: string): Promise<any> {
    const stats = await this.prisma.task.groupBy({
      by: ['status'],
      where: {
        OR: [
          { creatorId: userId },
          { assigneeId: userId }
        ]
      },
      _count: {
        status: true
      }
    });
    
    const totalTasks = await this.prisma.task.count({
      where: {
        OR: [
          { creatorId: userId },
          { assigneeId: userId }
        ]
      }
    });
    
    const completedThisWeek = await this.prisma.task.count({
      where: {
        OR: [
          { creatorId: userId },
          { assigneeId: userId }
        ],
        status: TaskStatus.COMPLETED,
        completedAt: {
          gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
        }
      }
    });
    
    const overdueTasks = await this.prisma.task.count({
      where: {
        OR: [
          { creatorId: userId },
          { assigneeId: userId }
        ],
        dueDate: {
          lt: new Date()
        },
        status: {
          not: TaskStatus.COMPLETED
        }
      }
    });
    
    return {
      total: totalTasks,
      byStatus: stats.reduce((acc, stat) => {
        acc[stat.status] = stat._count.status;
        return acc;
      }, {}),
      completedThisWeek,
      overdueTasks,
      completionRate: totalTasks > 0 ? 
        (stats.find(s => s.status === TaskStatus.COMPLETED)?._count.status || 0) / totalTasks * 100 : 
        0
    };
  }
  
  private async analyzeTaskCompletion(task: Task): Promise<void> {
    try {
      const analysis = await this.claudeAI.analyzeTaskCompletion({
        task,
        estimatedTime: task.estimatedTime,
        actualTime: task.actualTime
      });
      
      // æ›´æ–°ä»»åŠ¡çš„AIåˆ†æç»“æœ
      await this.prisma.task.update({
        where: { id: task.id },
        data: {
          aiSuggestions: {
            ...task.aiSuggestions,
            completionAnalysis: analysis
          }
        }
      });
    } catch (error) {
      console.error('ä»»åŠ¡å®Œæˆåˆ†æå¤±è´¥:', error);
    }
  }
  
  private async checkUpdatePermission(task: Task, userId: string): Promise<boolean> {
    // ä»»åŠ¡åˆ›å»ºè€…å’Œè¢«æŒ‡æ´¾è€…éƒ½å¯ä»¥æ›´æ–°
    return task.creatorId === userId || task.assigneeId === userId;
  }
  
  private async handleTaskUpdateEffects(
    oldTask: Task,
    newTask: Task,
    userId: string
  ): Promise<void> {
    // è®°å½•æ›´æ–°æ´»åŠ¨
    await this.activity.recordActivity({
      type: 'TASK_UPDATED',
      action: 'æ›´æ–°äº†ä»»åŠ¡',
      userId,
      taskId: newTask.id,
      metadata: {
        changes: this.getTaskChanges(oldTask, newTask)
      }
    });
    
    // å¦‚æœæŒ‡æ´¾äººå‘˜å‘ç”Ÿå˜åŒ–ï¼Œå‘é€é€šçŸ¥
    if (oldTask.assigneeId !== newTask.assigneeId) {
      if (newTask.assigneeId) {
        await this.notification.sendTaskAssignedNotification(
          newTask.assigneeId,
          newTask
        );
      }
      
      if (oldTask.assigneeId && oldTask.assigneeId !== userId) {
        await this.notification.sendTaskUnassignedNotification(
          oldTask.assigneeId,
          newTask
        );
      }
    }
    
    // å¦‚æœæˆªæ­¢æ—¥æœŸå‘ç”Ÿå˜åŒ–ï¼Œå‘é€æé†’
    if (oldTask.dueDate !== newTask.dueDate && newTask.dueDate) {
      const daysUntilDue = Math.ceil(
        (newTask.dueDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
      );
      
      if (daysUntilDue <= 3 && newTask.assigneeId) {
        await this.notification.sendDueDateReminderNotification(
          newTask.assigneeId,
          newTask,
          daysUntilDue
        );
      }
    }
  }
  
  private getTaskChanges(oldTask: Task, newTask: Task): any {
    const changes: any = {};
    
    if (oldTask.title !== newTask.title) {
      changes.title = { from: oldTask.title, to: newTask.title };
    }
    
    if (oldTask.status !== newTask.status) {
      changes.status = { from: oldTask.status, to: newTask.status };
    }
    
    if (oldTask.priority !== newTask.priority) {
      changes.priority = { from: oldTask.priority, to: newTask.priority };
    }
    
    if (oldTask.assigneeId !== newTask.assigneeId) {
      changes.assignee = { from: oldTask.assigneeId, to: newTask.assigneeId };
    }
    
    return changes;
  }
}
```

#### Claude AIæœåŠ¡é›†æˆ

```typescript
// src/services/claudeAI.ts
import Anthropic from '@anthropic-ai/sdk';
import { Task, Category } from '@prisma/client';

export class ClaudeAIService {
  private claude: Anthropic;
  
  constructor() {
    this.claude = new Anthropic({
      apiKey: process.env.CLAUDE_API_KEY!,
    });
  }
  
  async enhanceTaskCreation(data: {
    title: string;
    description?: string;
    category?: string;
  }): Promise<any> {
    try {
      const prompt = this.buildTaskEnhancementPrompt(data);
      
      const response = await this.claude.messages.create({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 1000,
        messages: [{
          role: 'user',
          content: prompt
        }]
      });
      
      const content = response.content[0];
      if (content.type === 'text') {
        return JSON.parse(content.text);
      }
      
      return {};
    } catch (error) {
      console.error('Claude AIä»»åŠ¡å¢å¼ºå¤±è´¥:', error);
      return {};
    }
  }
  
  async generateTaskSuggestions(data: {
    title: string;
    description?: string;
  }): Promise<any> {
    try {
      const prompt = `
ä½œä¸ºä¸€ä¸ªæ™ºèƒ½ä»»åŠ¡ç®¡ç†åŠ©æ‰‹ï¼Œè¯·åˆ†æä»¥ä¸‹ä»»åŠ¡ä¿¡æ¯å¹¶æä¾›å»ºè®®ï¼š

ä»»åŠ¡æ ‡é¢˜: ${data.title}
ä»»åŠ¡æè¿°: ${data.description || 'æ— '}

è¯·ä»¥JSONæ ¼å¼è¿”å›ä»¥ä¸‹å»ºè®®ï¼š
{
  "priority": "å»ºè®®çš„ä¼˜å…ˆçº§ (low/medium/high/urgent)",
  "category": "å»ºè®®çš„åˆ†ç±»",
  "tags": ["å»ºè®®çš„æ ‡ç­¾1", "å»ºè®®çš„æ ‡ç­¾2"],
  "estimatedTime": "é¢„ä¼°å®Œæˆæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰",
  "complexity": "å¤æ‚åº¦è¯„åˆ† (1-10)",
  "suggestions": [
    "æ”¹è¿›å»ºè®®1",
    "æ”¹è¿›å»ºè®®2"
  ],
  "breakdown": [
    "å­ä»»åŠ¡1",
    "å­ä»»åŠ¡2"
  ]
}

è¯·åŸºäºä»»åŠ¡çš„å†…å®¹å’Œå¤æ‚åº¦ç»™å‡ºåˆç†å»ºè®®ã€‚
`;
      
      const response = await this.claude.messages.create({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 1000,
        messages: [{
          role: 'user',
          content: prompt
        }]
      });
      
      const content = response.content[0];
      if (content.type === 'text') {
        return JSON.parse(content.text);
      }
      
      return {};
    } catch (error) {
      console.error('Claude AIå»ºè®®ç”Ÿæˆå¤±è´¥:', error);
      return {};
    }
  }
  
  async generateProductivityInsights(data: {
    taskStats: any;
    completedTasks: Task[];
    userWorkingHours: string;
  }): Promise<any> {
    try {
      const prompt = `
ä½œä¸ºç”Ÿäº§åŠ›åˆ†æä¸“å®¶ï¼Œè¯·åˆ†æä»¥ä¸‹ç”¨æˆ·æ•°æ®å¹¶æä¾›æ´å¯Ÿï¼š

ä»»åŠ¡ç»Ÿè®¡:
- æ€»ä»»åŠ¡æ•°: ${data.taskStats.total}
- å·²å®Œæˆ: ${data.taskStats.completed}
- è¿›è¡Œä¸­: ${data.taskStats.inProgress}
- å®Œæˆç‡: ${data.taskStats.completionRate}%

æœ€è¿‘å®Œæˆçš„ä»»åŠ¡æ•°é‡: ${data.completedTasks.length}
å·¥ä½œæ—¶é—´: ${data.userWorkingHours}

è¯·ä»¥JSONæ ¼å¼è¿”å›åˆ†æç»“æœï¼š
{
  "productivity_score": "ç”Ÿäº§åŠ›è¯„åˆ† (0-100)",
  "trends": {
    "completion_trend": "å®Œæˆè¶‹åŠ¿åˆ†æ",
    "efficiency_trend": "æ•ˆç‡è¶‹åŠ¿åˆ†æ"
  },
  "recommendations": [
    {
      "title": "å»ºè®®æ ‡é¢˜",
      "description": "å…·ä½“å»ºè®®",
      "expectedImpact": "é¢„æœŸæ•ˆæœ",
      "priority": "ä¼˜å…ˆçº§ (high/medium/low)"
    }
  ],
  "insights": [
    "å…³é”®æ´å¯Ÿ1",
    "å…³é”®æ´å¯Ÿ2"
  ],
  "next_week_forecast": {
    "predicted_completion": "é¢„æµ‹ä¸‹å‘¨å®Œæˆä»»åŠ¡æ•°",
    "focus_areas": ["é‡ç‚¹å…³æ³¨é¢†åŸŸ1", "é‡ç‚¹å…³æ³¨é¢†åŸŸ2"]
  }
}

è¯·æä¾›å®ç”¨çš„ã€ä¸ªæ€§åŒ–çš„å»ºè®®ã€‚
`;
      
      const response = await this.claude.messages.create({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 1500,
        messages: [{
          role: 'user',
          content: prompt
        }]
      });
      
      const content = response.content[0];
      if (content.type === 'text') {
        return JSON.parse(content.text);
      }
      
      return {};
    } catch (error) {
      console.error('Claude AIç”Ÿäº§åŠ›æ´å¯Ÿç”Ÿæˆå¤±è´¥:', error);
      return {};
    }
  }
  
  async optimizeTaskSchedule(tasks: Task[]): Promise<any> {
    try {
      const taskData = tasks.map(task => ({
        id: task.id,
        title: task.title,
        priority: task.priority,
        estimatedTime: task.estimatedTime,
        dueDate: task.dueDate,
        complexity: task.complexityScore
      }));
      
      const prompt = `
ä½œä¸ºä»»åŠ¡è°ƒåº¦ä¼˜åŒ–ä¸“å®¶ï¼Œè¯·ä¸ºä»¥ä¸‹ä»»åŠ¡åˆ—è¡¨åˆ¶å®šæœ€ä¼˜çš„æ‰§è¡Œè®¡åˆ’ï¼š

ä»»åŠ¡åˆ—è¡¨: ${JSON.stringify(taskData, null, 2)}

è¯·è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼š
1. ä»»åŠ¡ä¼˜å…ˆçº§
2. æˆªæ­¢æ—¥æœŸ
3. é¢„ä¼°æ—¶é—´
4. ä»»åŠ¡å¤æ‚åº¦
5. å·¥ä½œæ•ˆç‡æœ€ä¼˜æ—¶é—´æ®µ

è¯·ä»¥JSONæ ¼å¼è¿”å›ä¼˜åŒ–åçš„æ’ç¨‹ï¼š
{
  "optimized_schedule": [
    {
      "task_id": "ä»»åŠ¡ID",
      "recommended_start": "å»ºè®®å¼€å§‹æ—¶é—´",
      "recommended_duration": "å»ºè®®æ‰§è¡Œæ—¶é•¿",
      "reasoning": "æ’ç¨‹ç†ç”±"
    }
  ],
  "schedule_insights": [
    "æ’ç¨‹æ´å¯Ÿ1",
    "æ’ç¨‹æ´å¯Ÿ2"
  ],
  "productivity_tips": [
    "ç”Ÿäº§åŠ›å»ºè®®1",
    "ç”Ÿäº§åŠ›å»ºè®®2"
  ]
}
`;
      
      const response = await this.claude.messages.create({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 2000,
        messages: [{
          role: 'user',
          content: prompt
        }]
      });
      
      const content = response.content[0];
      if (content.type === 'text') {
        return JSON.parse(content.text);
      }
      
      return {};
    } catch (error) {
      console.error('Claude AIä»»åŠ¡è°ƒåº¦ä¼˜åŒ–å¤±è´¥:', error);
      return {};
    }
  }
  
  async analyzeTaskCompletion(data: {
    task: Task;
    estimatedTime?: number;
    actualTime?: number;
  }): Promise<any> {
    try {
      const prompt = `
è¯·åˆ†æä»¥ä¸‹ä»»åŠ¡å®Œæˆæƒ…å†µï¼š

ä»»åŠ¡ä¿¡æ¯:
- æ ‡é¢˜: ${data.task.title}
- é¢„ä¼°æ—¶é—´: ${data.estimatedTime || 'æœªè®¾ç½®'} åˆ†é’Ÿ
- å®é™…ç”¨æ—¶: ${data.actualTime || 'æœªè®°å½•'} åˆ†é’Ÿ
- ä¼˜å…ˆçº§: ${data.task.priority}
- å¤æ‚åº¦: ${data.task.complexityScore || 'æœªè¯„ä¼°'}

è¯·æä¾›åˆ†æç»“æœï¼š
{
  "efficiency_score": "æ•ˆç‡è¯„åˆ† (0-100)",
  "time_accuracy": "æ—¶é—´é¢„ä¼°å‡†ç¡®åº¦",
  "performance_feedback": "è¡¨ç°åé¦ˆ",
  "improvement_suggestions": [
    "æ”¹è¿›å»ºè®®1",
    "æ”¹è¿›å»ºè®®2"
  ],
  "learning_insights": [
    "å­¦ä¹ æ´å¯Ÿ1",
    "å­¦ä¹ æ´å¯Ÿ2"
  ]
}
`;
      
      const response = await this.claude.messages.create({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 1000,
        messages: [{
          role: 'user',
          content: prompt
        }]
      });
      
      const content = response.content[0];
      if (content.type === 'text') {
        return JSON.parse(content.text);
      }
      
      return {};
    } catch (error) {
      console.error('Claude AIä»»åŠ¡å®Œæˆåˆ†æå¤±è´¥:', error);
      return {};
    }
  }
  
  private buildTaskEnhancementPrompt(data: any): string {
    return `
ä½œä¸ºæ™ºèƒ½ä»»åŠ¡ç®¡ç†ç³»ç»Ÿï¼Œè¯·åˆ†æå¹¶å¢å¼ºä»¥ä¸‹ä»»åŠ¡ï¼š

ä»»åŠ¡æ ‡é¢˜: ${data.title}
ä»»åŠ¡æè¿°: ${data.description || 'æ— '}
åˆ†ç±»: ${data.category || 'æœªåˆ†ç±»'}

è¯·è¿”å›JSONæ ¼å¼çš„å¢å¼ºä¿¡æ¯ï¼š
{
  "priority": "å»ºè®®ä¼˜å…ˆçº§",
  "estimatedTime": é¢„ä¼°æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰,
  "complexityScore": å¤æ‚åº¦è¯„åˆ†ï¼ˆ1-10ï¼‰,
  "tags": ["ç›¸å…³æ ‡ç­¾"],
  "breakdown": ["å­ä»»åŠ¡åˆ†è§£"],
  "dependencies": ["å¯èƒ½çš„ä¾èµ–"],
  "resources": ["éœ€è¦çš„èµ„æº"],
  "risks": ["æ½œåœ¨é£é™©"],
  "success_criteria": ["æˆåŠŸæ ‡å‡†"]
}
`;
  }
}
```

## å®æ—¶åŠŸèƒ½å’ŒWebSocket

### WebSocketå®æ—¶åä½œ

```typescript
// src/services/websocket.ts
import { Server as SocketServer } from 'socket.io';
import { verifyJWT } from '../utils/jwt';
import { prisma } from '../app';

interface AuthenticatedSocket extends Socket {
  userId?: string;
}

export function setupWebSocket(io: SocketServer) {
  // èº«ä»½éªŒè¯ä¸­é—´ä»¶
  io.use(async (socket: AuthenticatedSocket, next) => {
    try {
      const token = socket.handshake.auth.token;
      if (!token) {
        return next(new Error('æœªæä¾›è®¤è¯ä»¤ç‰Œ'));
      }
      
      const decoded = verifyJWT(token);
      socket.userId = decoded.userId;
      next();
    } catch (error) {
      next(new Error('è®¤è¯å¤±è´¥'));
    }
  });
  
  io.on('connection', (socket: AuthenticatedSocket) => {
    console.log(`ç”¨æˆ· ${socket.userId} å·²è¿æ¥`);
    
    // åŠ å…¥ç”¨æˆ·æˆ¿é—´
    socket.join(`user:${socket.userId}`);
    
    // ä»»åŠ¡ç›¸å…³äº‹ä»¶
    setupTaskEvents(socket, io);
    
    // åä½œç¼–è¾‘äº‹ä»¶
    setupCollaborationEvents(socket, io);
    
    // é€šçŸ¥äº‹ä»¶
    setupNotificationEvents(socket, io);
    
    socket.on('disconnect', () => {
      console.log(`ç”¨æˆ· ${socket.userId} å·²æ–­å¼€è¿æ¥`);
    });
  });
}

function setupTaskEvents(socket: AuthenticatedSocket, io: SocketServer) {
  // åŠ å…¥ä»»åŠ¡æˆ¿é—´
  socket.on('join-task', (taskId: string) => {
    socket.join(`task:${taskId}`);
    
    // é€šçŸ¥å…¶ä»–ç”¨æˆ·æœ‰äººåŠ å…¥äº†ä»»åŠ¡
    socket.to(`task:${taskId}`).emit('user-joined-task', {
      userId: socket.userId,
      taskId
    });
  });
  
  // ç¦»å¼€ä»»åŠ¡æˆ¿é—´
  socket.on('leave-task', (taskId: string) => {
    socket.leave(`task:${taskId}`);
    
    // é€šçŸ¥å…¶ä»–ç”¨æˆ·æœ‰äººç¦»å¼€äº†ä»»åŠ¡
    socket.to(`task:${taskId}`).emit('user-left-task', {
      userId: socket.userId,
      taskId
    });
  });
  
  // ä»»åŠ¡çŠ¶æ€æ›´æ–°
  socket.on('task-status-update', async (data: {
    taskId: string;
    status: string;
    comment?: string;
  }) => {
    try {
      // æ›´æ–°æ•°æ®åº“
      const task = await prisma.task.update({
        where: { id: data.taskId },
        data: { status: data.status as any },
        include: {
          creator: true,
          assignee: true
        }
      });
      
      // å¹¿æ’­ç»™æ‰€æœ‰åœ¨ä»»åŠ¡æˆ¿é—´çš„ç”¨æˆ·
      io.to(`task:${data.taskId}`).emit('task-updated', {
        task,
        updatedBy: socket.userId,
        changes: { status: data.status },
        comment: data.comment
      });
      
      // å‘é€ç»™ä»»åŠ¡ç›¸å…³çš„ç”¨æˆ·
      if (task.assigneeId && task.assigneeId !== socket.userId) {
        io.to(`user:${task.assigneeId}`).emit('task-notification', {
          type: 'status-changed',
          task,
          message: `ä»»åŠ¡ "${task.title}" çŠ¶æ€å·²æ›´æ–°ä¸º ${data.status}`
        });
      }
      
    } catch (error) {
      socket.emit('error', { message: 'æ›´æ–°ä»»åŠ¡çŠ¶æ€å¤±è´¥' });
    }
  });
  
  // å®æ—¶è¯„è®º
  socket.on('add-comment', async (data: {
    taskId: string;
    content: string;
  }) => {
    try {
      const comment = await prisma.comment.create({
        data: {
          content: data.content,
          taskId: data.taskId,
          userId: socket.userId!
        },
        include: {
          user: true
        }
      });
      
      // å¹¿æ’­æ–°è¯„è®º
      io.to(`task:${data.taskId}`).emit('new-comment', comment);
      
    } catch (error) {
      socket.emit('error', { message: 'æ·»åŠ è¯„è®ºå¤±è´¥' });
    }
  });
}

function setupCollaborationEvents(socket: AuthenticatedSocket, io: SocketServer) {
  // ç”¨æˆ·æ­£åœ¨ç¼–è¾‘ä»»åŠ¡
  socket.on('start-editing', (data: {
    taskId: string;
    field: string;
  }) => {
    socket.to(`task:${data.taskId}`).emit('user-editing', {
      userId: socket.userId,
      taskId: data.taskId,
      field: data.field
    });
  });
  
  // ç”¨æˆ·åœæ­¢ç¼–è¾‘
  socket.on('stop-editing', (data: {
    taskId: string;
    field: string;
  }) => {
    socket.to(`task:${data.taskId}`).emit('user-stopped-editing', {
      userId: socket.userId,
      taskId: data.taskId,
      field: data.field
    });
  });
  
  // å®æ—¶æ–‡æœ¬åŒæ­¥ (åä½œç¼–è¾‘)
  socket.on('text-change', (data: {
    taskId: string;
    field: string;
    content: string;
    cursor: number;
  }) => {
    socket.to(`task:${data.taskId}`).emit('text-updated', {
      userId: socket.userId,
      ...data
    });
  });
}

function setupNotificationEvents(socket: AuthenticatedSocket, io: SocketServer) {
  // æ ‡è®°é€šçŸ¥ä¸ºå·²è¯»
  socket.on('mark-notification-read', async (notificationId: string) => {
    try {
      await prisma.notification.update({
        where: { id: notificationId },
        data: { isRead: true }
      });
      
      socket.emit('notification-marked-read', { notificationId });
    } catch (error) {
      socket.emit('error', { message: 'æ ‡è®°é€šçŸ¥å¤±è´¥' });
    }
  });
  
  // è·å–æœªè¯»é€šçŸ¥æ•°é‡
  socket.on('get-unread-count', async () => {
    try {
      const count = await prisma.notification.count({
        where: {
          userId: socket.userId,
          isRead: false
        }
      });
      
      socket.emit('unread-count', { count });
    } catch (error) {
      socket.emit('error', { message: 'è·å–æœªè¯»é€šçŸ¥æ•°é‡å¤±è´¥' });
    }
  });
}

// å‘é€å®æ—¶é€šçŸ¥çš„è¾…åŠ©å‡½æ•°
export async function sendRealTimeNotification(
  io: SocketServer,
  userId: string,
  notification: any
) {
  io.to(`user:${userId}`).emit('new-notification', notification);
}

// å¹¿æ’­ä»»åŠ¡æ›´æ–°
export async function broadcastTaskUpdate(
  io: SocketServer,
  taskId: string,
  task: any,
  changes: any,
  updatedBy: string
) {
  io.to(`task:${taskId}`).emit('task-updated', {
    task,
    changes,
    updatedBy,
    timestamp: new Date().toISOString()
  });
}
```

## éƒ¨ç½²å’ŒDevOps

### 1. Dockerå®¹å™¨åŒ–

#### å¤šé˜¶æ®µæ„å»ºDockerfile

```dockerfile
# Frontend Dockerfile
FROM node:18-alpine AS frontend-builder

WORKDIR /app

# å¤åˆ¶packageæ–‡ä»¶
COPY package*.json ./
RUN npm ci --only=production

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºå‰ç«¯
RUN npm run build

# ç”Ÿäº§ç¯å¢ƒé•œåƒ
FROM nginx:alpine AS frontend-production

# å¤åˆ¶æ„å»ºç»“æœ
COPY --from=frontend-builder /app/dist /usr/share/nginx/html

# å¤åˆ¶nginxé…ç½®
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]

---

# Backend Dockerfile
FROM node:18-alpine AS backend-builder

WORKDIR /app

# å¤åˆ¶packageæ–‡ä»¶
COPY package*.json ./
COPY prisma ./prisma/

# å®‰è£…ä¾èµ–
RUN npm ci --only=production

# ç”ŸæˆPrismaå®¢æˆ·ç«¯
RUN npx prisma generate

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºTypeScript
RUN npm run build

# ç”Ÿäº§ç¯å¢ƒé•œåƒ
FROM node:18-alpine AS backend-production

WORKDIR /app

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup -g 1001 -S nodejs
RUN adduser -S taskflow -u 1001

# å¤åˆ¶ä¾èµ–å’Œæ„å»ºç»“æœ
COPY --from=backend-builder --chown=taskflow:nodejs /app/node_modules ./node_modules
COPY --from=backend-builder --chown=taskflow:nodejs /app/dist ./dist
COPY --from=backend-builder --chown=taskflow:nodejs /app/prisma ./prisma
COPY --from=backend-builder --chown=taskflow:nodejs /app/package*.json ./

USER taskflow

EXPOSE 3001

CMD ["npm", "start"]
```

#### Docker Composeé…ç½®

```yaml
# docker-compose.yml
version: '3.8'

services:
  # PostgreSQLæ•°æ®åº“
  postgres:
    image: postgres:15-alpine
    container_name: taskflow-postgres
    environment:
      POSTGRES_DB: taskflow
      POSTGRES_USER: taskflow
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - taskflow-network
    restart: unless-stopped

  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    container_name: taskflow-redis
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - taskflow-network
    restart: unless-stopped

  # åç«¯APIæœåŠ¡
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
      target: backend-production
    container_name: taskflow-backend
    environment:
      NODE_ENV: production
      DATABASE_URL: postgresql://taskflow:${POSTGRES_PASSWORD}@postgres:5432/taskflow
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      JWT_SECRET: ${JWT_SECRET}
      CLAUDE_API_KEY: ${CLAUDE_API_KEY}
      SENDGRID_API_KEY: ${SENDGRID_API_KEY}
    depends_on:
      - postgres
      - redis
    ports:
      - "3001:3001"
    networks:
      - taskflow-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # å‰ç«¯åº”ç”¨
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: frontend-production
    container_name: taskflow-frontend
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - backend
    networks:
      - taskflow-network
    restart: unless-stopped
    volumes:
      - ./ssl:/etc/nginx/ssl:ro

  # Nginxè´Ÿè½½å‡è¡¡å™¨
  nginx:
    image: nginx:alpine
    container_name: taskflow-nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - frontend
      - backend
    networks:
      - taskflow-network
    restart: unless-stopped

  # ç›‘æ§æœåŠ¡
  prometheus:
    image: prom/prometheus:latest
    container_name: taskflow-prometheus
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    ports:
      - "9090:9090"
    networks:
      - taskflow-network
    restart: unless-stopped

  grafana:
    image: grafana/grafana:latest
    container_name: taskflow-grafana
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
    ports:
      - "3000:3000"
    depends_on:
      - prometheus
    networks:
      - taskflow-network
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:

networks:
  taskflow-network:
    driver: bridge
```

### 2. CI/CD Pipeline

#### GitHub Actionså·¥ä½œæµ

```yaml
# .github/workflows/deploy.yml
name: Deploy TaskFlow AI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: taskflow_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: |
          cd backend && npm ci
          cd ../frontend && npm ci

      - name: Run backend tests
        run: |
          cd backend
          npm run test
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/taskflow_test

      - name: Run frontend tests
        run: |
          cd frontend
          npm run test

      - name: Run E2E tests
        run: |
          cd frontend
          npm run test:e2e

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."
          # è¿™é‡Œå¯ä»¥æ·»åŠ éƒ¨ç½²åˆ°stagingç¯å¢ƒçš„è„šæœ¬

  deploy-production:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Deploy to production
        run: |
          echo "Deploying to production environment..."
          # è¿™é‡Œå¯ä»¥æ·»åŠ éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒçš„è„šæœ¬

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."
          # æ·»åŠ ç”Ÿäº§ç¯å¢ƒçƒŸé›¾æµ‹è¯•
```

## æ€»ç»“ï¼šå…¨æ ˆå¼€å‘çš„AIé©å‘½

é€šè¿‡TaskFlow AIé¡¹ç›®çš„å®Œæ•´å®è·µï¼Œä½ å·²ç»æŒæ¡äº†ï¼š

### ğŸ¯ ç°ä»£å…¨æ ˆæ ¸å¿ƒæŠ€èƒ½

1. **å‰ç«¯ç°ä»£åŒ–å¼€å‘**ï¼šReact 18 + TypeScript + Tailwind CSSçš„æœ€ä½³å®è·µ
2. **åç«¯æ¶æ„è®¾è®¡**ï¼šNode.js + Express + Prismaçš„ä¼ä¸šçº§æ¶æ„
3. **AIé›†æˆå¼€å‘**ï¼šClaude APIçš„æ·±åº¦é›†æˆå’Œæ™ºèƒ½åŠŸèƒ½å®ç°
4. **å®æ—¶åä½œåŠŸèƒ½**ï¼šWebSocketé©±åŠ¨çš„å®æ—¶åŒæ­¥å’Œåä½œ
5. **DevOpsæœ€ä½³å®è·µ**ï¼šDockerå®¹å™¨åŒ–å’ŒCI/CDè‡ªåŠ¨åŒ–éƒ¨ç½²

### âš¡ AIå¢å¼ºçš„å¼€å‘æ•ˆç‡

| å¼€å‘ç¯èŠ‚ | ä¼ ç»Ÿæ–¹å¼ | AIå¢å¼ºæ–¹å¼ | æ•ˆç‡æå‡ |
|---------|----------|------------|------------|
| éœ€æ±‚åˆ†æ | äººå·¥åˆ†æï¼Œç»éªŒä¾èµ– | AIè¾…åŠ©åˆ†æï¼Œæ™ºèƒ½å»ºè®® | åˆ†æé€Ÿåº¦3-5å€ |
| ä»£ç ç”Ÿæˆ | æ‰‹å†™ä»£ç ï¼ŒæŸ¥æ‰¾æ–‡æ¡£ | AIç”Ÿæˆæ¡†æ¶ï¼Œæ™ºèƒ½è¡¥å…¨ | ç¼–ç é€Ÿåº¦5-10å€ |
| ä¸šåŠ¡é€»è¾‘ | é€æ­¥å®ç°ï¼Œåå¤æµ‹è¯• | AIæ¨èæ–¹æ¡ˆï¼Œå¿«é€ŸéªŒè¯ | å¼€å‘é€Ÿåº¦2-3å€ |
| ç”¨æˆ·ä½“éªŒ | äººå·¥è®¾è®¡ï¼ŒA/Bæµ‹è¯• | AIä¸ªæ€§åŒ–ï¼Œæ™ºèƒ½æ¨è | ç”¨æˆ·ä½“éªŒ2å€+ |
| è¿ç»´éƒ¨ç½² | æ‰‹åŠ¨é…ç½®ï¼Œç»éªŒè°ƒä¼˜ | æ™ºèƒ½é…ç½®ï¼Œè‡ªåŠ¨ä¼˜åŒ– | éƒ¨ç½²æ•ˆç‡5å€+ |

### ğŸ› ï¸ å…¨æ ˆæŠ€æœ¯ç”Ÿæ€

- **å‰ç«¯æŠ€æœ¯æ ˆ**ï¼šReactã€TypeScriptã€Tailwind CSSã€Viteã€React Query
- **åç«¯æŠ€æœ¯æ ˆ**ï¼šNode.jsã€Expressã€TypeScriptã€Prismaã€PostgreSQL
- **AIé›†æˆ**ï¼šClaude APIã€æ™ºèƒ½æ¨èã€è‡ªåŠ¨åˆ†æã€ä¼˜åŒ–å»ºè®®
- **å®æ—¶åŠŸèƒ½**ï¼šWebSocketã€Socket.ioã€å®æ—¶åä½œã€æ¶ˆæ¯æ¨é€
- **éƒ¨ç½²è¿ç»´**ï¼šDockerã€Nginxã€CI/CDã€ç›‘æ§å‘Šè­¦

### ğŸš€ å…¨æ ˆå‘å±•è¶‹åŠ¿

1. **AIåŸç”Ÿå¼€å‘**ï¼šAIä¸å†æ˜¯é™„åŠ åŠŸèƒ½ï¼Œè€Œæ˜¯æ ¸å¿ƒé©±åŠ¨åŠ›
2. **ä½ä»£ç /æ— ä»£ç **ï¼šå¯è§†åŒ–å¼€å‘å·¥å…·å’ŒAIè¾…åŠ©ç¼–ç¨‹
3. **è¾¹ç¼˜è®¡ç®—é›†æˆ**ï¼šå‰ç«¯AIæ¨ç†å’Œè¾¹ç¼˜è®¡ç®—èƒ½åŠ›
4. **å®æ—¶åä½œæ ‡å‡†**ï¼šå®æ—¶åŒæ­¥æˆä¸ºWebåº”ç”¨æ ‡é…
5. **å…¨æ ˆTypeScript**ï¼šç±»å‹å®‰å…¨è´¯ç©¿æ•´ä¸ªåº”ç”¨æ ˆ

é€šè¿‡Claude Codeçš„å…¨æ ˆå¼€å‘å®è·µï¼Œæˆ‘ä»¬å®ç°äº†ä»**ä¼ ç»Ÿå¼€å‘åˆ°AIå¢å¼ºå¼€å‘**ï¼Œä»**å•ä¸€æŠ€èƒ½åˆ°å…¨æ ˆèƒ½åŠ›**çš„è·ƒå‡ã€‚è¿™ä¸ä»…æé«˜äº†å¼€å‘æ•ˆç‡ï¼Œæ›´ä¸ºç°ä»£Webåº”ç”¨å¼€å‘æ ‘ç«‹äº†æ–°çš„æ ‡å‡†ã€‚

åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¢ç´¢å¾®æœåŠ¡æ¶æ„é¡¹ç›®å®è·µï¼Œå­¦ä¹ å¦‚ä½•æ„å»ºå¯æ‰©å±•çš„åˆ†å¸ƒå¼ç³»ç»Ÿã€‚

## ç›¸å…³æ–‡ç« æ¨è

- [ç›‘æ§ä¸è¿ç»´ï¼šç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ](27-ç›‘æ§ä¸è¿ç»´ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ.md)
- [å¾®æœåŠ¡æ¶æ„é¡¹ç›®å®è·µ](29-å¾®æœåŠ¡æ¶æ„é¡¹ç›®å®è·µ.md)
- [DevOpså·¥å…·é“¾é›†æˆæ¡ˆä¾‹](32-DevOpså·¥å…·é“¾é›†æˆæ¡ˆä¾‹.md)
- [æ€§èƒ½ä¼˜åŒ–ä¸è°ƒè¯•æŠ€å·§](36-æ€§èƒ½ä¼˜åŒ–ä¸è°ƒè¯•æŠ€å·§.md)

---

*æœ¬æ–‡æ˜¯ã€ŠClaude Code å®Œæ•´æ•™ç¨‹ç³»åˆ—ã€‹çš„ç¬¬äºŒåå…«éƒ¨åˆ†ã€‚æŒæ¡äº†å…¨æ ˆWebåº”ç”¨å¼€å‘ï¼Œè®©æˆ‘ä»¬ç»§ç»­æ¢ç´¢å¾®æœåŠ¡æ¶æ„çš„å¥¥ç§˜ï¼*